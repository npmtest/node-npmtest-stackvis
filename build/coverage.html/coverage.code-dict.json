{"/home/travis/build/npmtest/node-npmtest-stackvis/test.js":"/* istanbul instrument in package npmtest_stackvis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stackvis/lib.npmtest_stackvis.js":"/* istanbul instrument in package npmtest_stackvis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stackvis = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stackvis = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stackvis/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stackvis && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stackvis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stackvis\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stackvis.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_stackvis.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stackvis.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_stackvis.__dirname +\n                    '/lib.npmtest_stackvis.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/stackvis.js":"/*\n * lib/stackvis.js: Stackvis library interface\n */\n\nvar mod_assert = require('assert');\nvar mod_jsprim = require('jsprim');\n\nexports.readerLookup = readerLookup;\nexports.writerLookup = writerLookup;\nexports.pipeStacks = pipeStacks;\n\n/*\n * Readers read stacktraces stored in specific formats and emit them in a common\n * form.  Consumers don't use readers directly, but rather pass them to\n * pipeStacks().\n *\n * Each reader is defined in its own module.  It's expected to export a single\n * field called \"reader\" that's a constructor function, which we return here.\n * Reader constructors should be invoked as new constructor(ReadableStream,\n * BunyanLog).  The object itself should then emit \"stack\" and \"end\" events.\n * The \"stack\" event includes an array of frames and a count for the number of\n * times that stack was seen in the input:\n *\n *    reader.on('stack', function (frames, count) {\n *            console.log(count + ' ' + frames.join(', '));\n *    });\n *\n * Readers may emit the same stack more than once, which isn't what most\n * consumers want.  That's why the main API is pipeStacks, which collapses\n * common stacks.\n */\nfunction readerLookup(name)\n{\n\treturn (moduleLookup('input', name).reader);\n}\n\n/*\n * Writers take stacktraces stored in our common form and emit them in some\n * other specific format like a data file or a SVG visualization.  Like readers,\n * each writer is defined in its own module, and callers use them via\n * pipeStacks() rather than directly.\n *\n * Since writers do not emit events, they're not constructors.  Each writer just\n * defines a single field called \"emit\", invoked as emit(args, callback).\n * \"args\" must contain these fields:\n *\n *    stacks\tStackSet\t\tStacks to visualize, as produced by\n *    \t\t\t\t\tcollapseStacks.\n *\n *    output\tWritableStream\t\tOutput file\n *\n *    log\tBunyan Logger\t\tLogger\n *\n * as well as any other module-specific parameters.\n */\nfunction writerLookup(name)\n{\n\treturn (moduleLookup('output', name));\n}\n\nfunction moduleLookup(type, name)\n{\n\tvar filename = './' + type + '-' + name;\n\treturn (require(filename));\n}\n\n/*\n * Reads stacks from \"instream\" (a ReadableStream) using a new \"readercons\"\n * Reader object, collapses the stacks, and emits them to \"outstream\" using the\n * given writer.  This is the main way to convert stacks from one representation\n * (e.g., DTrace output) to another (e.g., a flamegraph).\n *\n * This is the primary interface for consumers, though it's *not* a stable\n * interface yet.\n */\nfunction pipeStacks(log, instream, readercons, writer, outstream, args,\n    callback)\n{\n\tif (typeof (args) === 'function') {\n\t\tcallback = args;\n\t\targs = {};\n\t}\n\targs = args || {};\n\n\tvar reader = new readercons(instream, log);\n\n\tcollapseStacks(reader, function (err, stacks) {\n\t\tif (err) {\n\t\t\tlog.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tvar _args = mod_jsprim.deepCopy(args);\n\t\t_args.stacks = stacks;\n\t\t_args.output = outstream;\n\t\t_args.log = log;\n\t\twriter.emit(_args, function (err2) {\n\t\t\t/*\n\t\t\t * It's stupid that we need to check whether we're\n\t\t\t * writing to stdout, but this is the same thing Node's\n\t\t\t * stream.pipe() method does, because for some reason\n\t\t\t * you can't \"end\" the stdout stream.\n\t\t\t */\n\t\t\tif (!err2 && !outstream._isStdio)\n\t\t\t\toutstream.end();\n\n\t\t\tcallback(err2);\n\t\t});\n\t});\n}\n\n/*\n * Collects \"stack\" events from the given reader, collapses common stacks, and\n * returns them asynchronously via \"callback\".  This could reasonably be a\n * public interface, but for now we assume that the only consumers would be\n * translators which would use the slightly higher-level pipeStacks() instead.\n */\nfunction collapseStacks(reader, callback)\n{\n\tvar stacks = new StackSet();\n\n\treader.on('stack', function (stack, count) {\n\t\tstacks.addStack(stack, count);\n\t});\n\n\treader.on('end', function () { callback(null, stacks); });\n}\n\n/*\n * Internal representation for a collapsed set of stacks.\n */\nfunction StackSet()\n{\n\tthis.ss_counts = {};\t/* maps serialized stack -> count */\n\tthis.ss_stacks = {};\t/* maps serialized stack -> stack */\n}\n\nStackSet.prototype.addStack = function (stack, count)\n{\n\tmod_assert.ok(Array.isArray(stack));\n\tmod_assert.equal(typeof (count), 'number');\n\n\tvar key = stack.join(',');\n\n\tif (!this.ss_counts.hasOwnProperty(key)) {\n\t\tthis.ss_counts[key] = 0;\n\t\tthis.ss_stacks[key] = stack;\n\t}\n\n\tthis.ss_counts[key] += count;\n};\n\n/*\n * Iterates all stacks in order of decreasing count.  The callback function is\n * invoked as callback(frames, count) for each unique stack.\n */\nStackSet.prototype.eachStackByCount = function (callback)\n{\n\tvar set = this;\n\tvar keys = Object.keys(this.ss_stacks);\n\n\tkeys.sort(function (a, b) {\n\t\treturn (set.ss_counts[b] - set.ss_counts[a]);\n\t});\n\n\tkeys.forEach(function (key) {\n\t\tcallback(set.ss_stacks[key], set.ss_counts[key]);\n\t});\n};\n\n/*\n * Iterates all stacks in alphabetical order by full stack.\n */\nStackSet.prototype.eachStackByStack = function (callback)\n{\n\tvar set = this;\n\tvar keys = Object.keys(this.ss_stacks);\n\n\tkeys.sort().forEach(function (key) {\n\t\tcallback(set.ss_stacks[key], set.ss_counts[key]);\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/color.js":"/*\n * lib/color.js: color utility functions\n */\n\nvar mod_assert = require('assert');\n\n/*\n * Convert from HSV to RGB.  Ported from the Java implementation by Eugene\n * Vishnevsky:\n *\n *   http://www.cs.rit.edu/~ncs/color/t_convert.html\n */\nexports.convertHsvToRgb = function convertHsvToRgb(h, s, v)\n{\n\tvar r, g, b;\n\tvar i;\n\tvar f, p, q, t;\n\n\tmod_assert.ok(h >= 0 && h <= 360, 'hue (' + h + ') out of range');\n\tmod_assert.ok(s >= 0 && s <= 1, 'saturation (' + s + ') out of range');\n\tmod_assert.ok(v >= 0 && v <= 1, 'value (' + v + ') out of range');\n\n\tif (s === 0) {\n\t\t/*\n\t\t * A saturation of 0.0 is achromatic (grey).\n\t\t */\n\t\tr = g = b = v;\n\n\t\treturn ([ Math.round(r * 255), Math.round(g * 255),\n\t\t    Math.round(b * 255) ]);\n\t}\n\n\th /= 60; // sector 0 to 5\n\n\ti = Math.floor(h);\n\tf = h - i; // fractional part of h\n\tp = v * (1 - s);\n\tq = v * (1 - s * f);\n\tt = v * (1 - s * (1 - f));\n\n\tswitch (i) {\n\t\tcase 0:\n\t\t\tr = v;\n\t\t\tg = t;\n\t\t\tb = p;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tr = q;\n\t\t\tg = v;\n\t\t\tb = p;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tr = p;\n\t\t\tg = v;\n\t\t\tb = t;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tr = p;\n\t\t\tg = q;\n\t\t\tb = v;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tr = t;\n\t\t\tg = p;\n\t\t\tb = v;\n\t\t\tbreak;\n\n\t\tdefault: // case 5:\n\t\t\tr = v;\n\t\t\tg = p;\n\t\t\tb = q;\n\t\t\tbreak;\n\t}\n\n\treturn ([ Math.round(r * 255),\n\t    Math.round(g * 255), Math.round(b * 255) ]);\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/demo.js":"/*\n * demo.js: static-file node HTTP server for demos\n *\n * Usage: node demo.js [port]\n *\n *    Sets up a web server on the given port (or port 80) serving static files\n *    out of the given path.  This demo is NOT secure and allows anyone with\n *    network access to this server to read any files on your system.\n */\n\nvar mod_fs = require('fs');\nvar mod_http = require('http');\nvar mod_path = require('path');\nvar mod_url = require('url');\n\nvar dd_index = 'index.htm';\nvar dd_cwd = process.cwd();\nvar dd_port = 80;\n\nvar i;\n\nfor (i = 2; i < process.argv.length; i++) {\n\tdd_port = parseInt(process.argv[i], 10);\n\tif (isNaN(dd_port)) {\n\t\tconsole.error('usage: node demo.js [port]');\n\t\tprocess.exit(1);\n\t}\n}\n\nmod_http.createServer(function (req, res) {\n\tvar uri = mod_url.parse(req.url).pathname;\n\tvar path;\n\tvar filename;\n\n\tpath = (uri == '/') ? dd_index : uri;\n\n\tfilename = mod_path.join(dd_cwd, path);\n\n\tmod_fs.readFile(filename, function (err, file) {\n\t\tif (err) {\n\t\t\tres.writeHead(404);\n\t\t\tres.end();\n\t\t\treturn;\n\t\t}\n\n\t\tres.writeHead(200);\n\t\tres.end(file);\n\t});\n}).listen(dd_port, function () {\n\tconsole.log('HTTP server started on port ' + dd_port);\n});\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/input-collapsed.js":"/*\n * lib/input-collapsed.js: reads output from the \"stackcollapse\" script\n */\n\nvar mod_util = require('util');\nvar mod_events = require('events');\n\nvar mod_carrier = require('carrier');\n\nexports.reader = CollapsedStreamReader;\n\nfunction CollapsedStreamReader(input, log)\n{\n\tvar reader = this;\n\n\tthis.csr_log = log;\n\tthis.csr_linenum = 0;\n\tthis.csr_carrier = mod_carrier.carry(input);\n\tthis.csr_carrier.on('line', function (line) {\n\t\treader.csr_linenum++;\n\t\tvar match = /^(.*)\\s+(\\d+)$/.exec(line);\n\t\tif (!match) {\n\t\t\tlog.warn('line ' + reader.csr_linenum + ': garbled');\n\t\t\treturn;\n\t\t}\n\n\t\treader.emit('stack', match[1].split(','),\n\t\t    parseInt(match[2], 10));\n\t});\n\tthis.csr_carrier.on('end', function () { reader.emit('end'); });\n}\n\nmod_util.inherits(CollapsedStreamReader, mod_events.EventEmitter);\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/input-dtrace.js":"/*\n * lib/input-dtrace.js: reads output from a DTrace profiling script, which emits\n * stanzas that look like this:\n *\n *            prog`foo+0x8\n *            prog`main+0x21\n *            prog`_start+0x80\n *             14\n *\n * This examples shows that that particular stacktrace was seen 14 times.  You\n * can generate such output with:\n *\n *   # dtrace -o stacks.out \\\n *     -n 'profile-97/execname == \"myprogram\"/{ @[ustack()] = count(); }'\n */\n\nvar mod_util = require('util');\nvar mod_events = require('events');\n\nvar mod_carrier = require('carrier');\n\n/* We always ignore the first 3 lines. */\nvar NHEADERLINES = 3;\n\nexports.reader = DTraceStreamReader;\n\nfunction DTraceStreamReader(input, log)\n{\n\tthis.dsr_log = log;\n\tthis.dsr_linenum = 0;\n\tthis.dsr_stack = [];\n\tthis.dsr_carrier = mod_carrier.carry(input);\n\tthis.dsr_carrier.on('line', this.onLine.bind(this));\n\tthis.dsr_carrier.on('end', this.onEnd.bind(this));\n\n\tmod_events.EventEmitter.call(this);\n}\n\nmod_util.inherits(DTraceStreamReader, mod_events.EventEmitter);\n\nDTraceStreamReader.prototype.onLine = function (line)\n{\n\t/* The first three lines are always ignored. */\n\tif (++this.dsr_linenum <= NHEADERLINES)\n\t\treturn;\n\n\tvar match = /^\\s+(\\d+)\\s*$/.exec(line);\n\tif (match) {\n\t\tif (this.dsr_stack.length === 0) {\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': found count with no stack');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.emit('stack', this.dsr_stack, parseInt(match[1], 10));\n\t\tthis.dsr_stack = [];\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, lines may have leading or trailing whitespace and the\n\t * following components:\n\t *\n\t *\tmodule`function+offset\n\t *\n\t * We try to avoid assuming too much about the form in order to support\n\t * various annotations provided by ustack helpers, but we want to strip\n\t * off the offset.\n\t */\n\tvar frame = line;\n\tframe = frame.replace(/^\\s+/, '');\n\tframe = frame.replace(/\\s+$/, '');\n\t/* JSSTYLED */\n\tframe = frame.replace(/\\+.*/, '');\n\n\t/*\n\t * Remove both function and template parameters from demangled C++\n\t * frames, but skip the first two characters because they're used by the\n\t * Node.js ustack helper as separators.\n\t */\n\t/* JSSTYLED */\n\tframe = frame.replace(/(..)[(<].*/, '$1');\n\n\tif (line.length === 0) {\n\t\tif (this.dsr_stack.length !== 0)\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': unexpected blank line');\n\t\treturn;\n\t}\n\n\tthis.dsr_stack.unshift(frame);\n};\n\nDTraceStreamReader.prototype.onEnd = function ()\n{\n\tif (this.dsr_stack.length !== 0)\n\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t    ': unexpected end of stream');\n\n\tthis.emit('end');\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/input-perf.js":"/*\n * lib/input-perf.js: reads output from a perf profiling script, which emits\n * stanzas that look like this:\n *\n * foo 15150 10062.190770: cycles:\n *                400675 bar (/tmp/stackvis/foo)\n *                400603 foo (/tmp/stackvis/foo)\n *                40071f main (/tmp/stackvis/foo)\n *          7fb3db1bf76d __libc_start_main (/lib/x86_64-linux-gnu/libc-2.15.so)\n *\n * You can generate such output with:\n *\n *   # perf record -F 997 -g ./myprogram\n *   # perf script > perf.out\n */\n\nvar mod_util = require('util');\nvar mod_events = require('events');\n\nvar mod_carrier = require('carrier');\n\nexports.reader = PerfStreamReader;\n\nfunction PerfStreamReader(input, log)\n{\n\tthis.dsr_log = log;\n\tthis.dsr_linenum = 0;\n\tthis.dsr_prefix = '';\n\tthis.dsr_stack = [];\n\tthis.dsr_carrier = mod_carrier.carry(input);\n\tthis.dsr_carrier.on('line', this.onLine.bind(this));\n\tthis.dsr_carrier.on('end', this.onEnd.bind(this));\n\n\tmod_events.EventEmitter.call(this);\n}\n\nmod_util.inherits(PerfStreamReader, mod_events.EventEmitter);\n\nPerfStreamReader.prototype.onLine = function (line)\n{\n\t++this.dsr_linenum;\n\n\t/* Lines beginning with # are always ignored. */\n\tif (/^#/.exec(line))\n\t\treturn;\n\n\t/* Get process name from summary line, to use as prefix */\n\tvar match = /(^\\w+)\\s+/.exec(line);\n\tif (match) {\n\t\tthis.dsr_prefix = match[1];\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, lines may have leading or trailing whitespace and the\n\t * following components:\n\t *\n\t *\tloc function (module)\n\t *\n\t * We try to avoid assuming too much about the form in order to support\n\t * various annotations provided by ustack helpers.\n\t */\n\tvar frame = line;\n\tframe = frame.replace(/^\\s+/, '');\n\tframe = frame.replace(/\\s+$/, '');\n\n\tif (frame.length === 0) {\n\t\tif (this.dsr_stack.length === 0) {\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': found empty line with no stack');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.emit('stack', this.dsr_stack, 1);\n\t\tthis.dsr_prefix = '';\n\t\tthis.dsr_stack = [];\n\t\treturn;\n\t}\n\n\tframe = frame.replace(/^\\w+ /, '');\n\tframe = frame.replace(/ \\(\\S+\\)$/, '');\n\n\t/*\n\t * Remove both function and template parameters from demangled C++\n\t * frames, but skip the first two characters because they're used by the\n\t * Node.js ustack helper as separators.\n\t */\n\t/* JSSTYLED */\n\tframe = frame.replace(/(..)[(<].*/, '$1');\n\n\tif (line.length === 0) {\n\t\tif (this.dsr_stack.length !== 0)\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': unexpected blank line');\n\t\treturn;\n\t}\n\n\t/* Add prefix */\n\tif (this.dsr_prefix.length > 0) {\n\t\tframe = this.dsr_prefix + '`' + frame;\n\t}\n\n\tthis.dsr_stack.unshift(frame);\n};\n\nPerfStreamReader.prototype.onEnd = function ()\n{\n\tif (this.dsr_stack.length !== 0)\n\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t    ': unexpected end of stream');\n\n\tthis.emit('end');\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/input-stap.js":"/*\n * lib/input-stap.js: reads output from a stap profiling script, which emits\n * stanzas that look like this:\n *\n * ubt[\"bar+0x32 [foo]\n * foo+0x57 [foo]\n * main+0x48 [foo]\n * __libc_start_main+0xed [libc-2.15.so]\n * _start+0x29 [foo]\"]=0x77\n *\n * You can generate such output with:\n *\n *   # stap \\\n *       -e \"global ubt; \\\n *           probe timer.profile { ubt[sprint_ubacktrace()] += 1 }; \\\n *           probe timer.s(30) { exit() }\" \\\n *       -o stap.out\n *\n * If stap warns about missing unwind data for a module, and stap\n * suggests adding '-d /lib/libquux.so', which you know to be a shared\n * library used by the 'foo' binary, add the following to the above\n * command:\n *\n *       -d /path/to/foo $(ldd /path/to/foo | awk 'NF==4 { print \"-d\", $3 }')\n *\n * to deal with all warnings related to shared libraries used by 'foo',\n * all at once.\n */\n\nvar mod_util = require('util');\nvar mod_events = require('events');\n\nvar mod_carrier = require('carrier');\n\nexports.reader = PerfStreamReader;\n\nfunction PerfStreamReader(input, log)\n{\n\tthis.dsr_log = log;\n\tthis.dsr_linenum = 0;\n\tthis.dsr_addingframes = false;\n\tthis.dsr_prefixes = [];\n\tthis.dsr_stack = [];\n\tthis.dsr_carrier = mod_carrier.carry(input);\n\tthis.dsr_carrier.on('line', this.onLine.bind(this));\n\tthis.dsr_carrier.on('end', this.onEnd.bind(this));\n\n\tmod_events.EventEmitter.call(this);\n}\n\nmod_util.inherits(PerfStreamReader, mod_events.EventEmitter);\n\nPerfStreamReader.prototype.onLine = function (line)\n{\n\t++this.dsr_linenum;\n\n\tvar match;\n\tif (!this.dsr_addingframes) {\n\t\t/* Skip array name */\n\t\tline.replace(/^\\w+\\[/, '');\n\n\t\t/* Find and add prefixes */\n\t\twhile (true) {\n\t\t\t/* JSSTYLED */\n\t\t\tmatch = /(?:\"([^\"]*)\",)(.*$)/.exec(line);\n\t\t\tif (!match)\n\t\t\t\tbreak;\n\t\t\tthis.dsr_prefixes.push(match[1]);\n\t\t\tline = match[2];\n\t\t}\n\n\t\t/* Find first frame */\n\t\t/* JSSTYLED */\n\t\tmatch = /(?:\"(.*$))/.exec(line);\n\t\tif (!match) {\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': no first frame found');\n\t\t\treturn;\n\t\t}\n\t\tline = match[1];\n\t\tthis.dsr_addingframes = true;\n\t}\n\n\t/* Look for count */\n\tvar count;\n\t/* JSSTYLED */\n\tmatch = /(^.*)\"\\]=(\\w+$)/.exec(line);\n\tif (match) {\n\t\tline = match[1];\n\t\tcount = parseInt(match[2], 16);\n\t\tthis.dsr_addingframes = false;\n\t}\n\n\t/*\n\t * In general, frames have one of the following sets of components:\n\t *\n\t *\taddress\n\t *\taddress [module+offset]\n\t *\tfunction+offset [module]\n\t *\n\t * We try to avoid assuming too much about the form in order to support\n\t * various annotations provided by ustack helpers.\n\t */\n\tvar frame = line;\n\tframe = frame.replace(/ \\[(\\S+)\\]$/, '');\n\t/* JSSTYLED */\n\tframe = frame.replace(/\\+.*/, '');\n\n\t/*\n\t * Remove both function and template parameters from demangled C++\n\t * frames, but skip the first two characters because they're used by the\n\t * Node.js ustack helper as separators.\n\t */\n\t/* JSSTYLED */\n\tframe = frame.replace(/(..)[(<].*/, '$1');\n\n\tif (line.length === 0) {\n\t\tif (this.dsr_stack.length !== 0)\n\t\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t\t    ': unexpected blank line');\n\t\treturn;\n\t}\n\n\t/* Add prefixes */\n\tif (this.dsr_prefixes.length > 0) {\n\t\tframe = this.dsr_prefixes.join('`') + '`' + frame;\n\t}\n\n\tthis.dsr_stack.unshift(frame);\n\n\tif (!this.dsr_addingframes) {\n\t\tthis.emit('stack', this.dsr_stack, count);\n\t\tthis.dsr_prefixes = [];\n\t\tthis.dsr_stack = [];\n\t}\n};\n\nPerfStreamReader.prototype.onEnd = function ()\n{\n\tif (this.dsr_stack.length !== 0)\n\t\tthis.dsr_log.warn('line ' + this.dsr_linenum +\n\t\t    ': unexpected end of stream');\n\n\tthis.emit('end');\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/output-collapsed.js":"/*\n * lib/output-collapsed.js: emits StackSets in collapsed format, compatible with\n * Brendan Gregg's FlameGraph tool.\n */\n\nvar mod_assert = require('assert');\n\n/*\n * Arguments:\n *\n *    stacks\tStackSet\t\tStacks to visualize\n *\n *    output\tWritableStream\t\tOutput file\n */\nexports.emit = function emitCollapsed(args, callback)\n{\n\tmod_assert.ok(args.stacks && args.stacks.constructor &&\n\t    args.stacks.constructor.name == 'StackSet',\n\t    'required \"stacks\" argument must be a StackSet');\n\tmod_assert.ok(args.output && args.output.write &&\n\t    typeof (args.output.write) == 'function',\n\t    'required \"output\" argument must be a function');\n\n\targs.stacks.eachStackByCount(function (frames, count) {\n\t\targs.output.write(frames.join(',') + ' ' + count + '\\n');\n\t});\n\tcallback();\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/output-flamegraph-d3.js":"/*\n * lib/output-flamegraph-d3.js: emits a D3-based HTML page for the flame graph.\n * See lib/stackvis.js for interface details.\n */\n\nvar mod_assert = require('assert');\nvar mod_fs = require('fs');\nvar mod_path = require('path');\n\nvar mod_hogan = require('hogan.js');\nvar mod_vasync = require('vasync');\nvar mod_verror = require('verror');\n\nvar VError = mod_verror.VError;\n\nexports.emit = function emitIcicleData(args, callback)\n{\n\tmod_assert.ok(args.stacks && args.stacks.constructor &&\n\t    args.stacks.constructor.name == 'StackSet',\n\t    'required \"stacks\" argument must be a StackSet');\n\tmod_assert.ok(args.output && args.output.write &&\n\t    typeof (args.output.write) == 'function',\n\t    'required \"output\" argument must be a function');\n\tmod_assert.ok(args.log, 'required \"log\" argument must be a logger');\n\n\tvar stacks = args.stacks;\n\tvar output = args.output;\n\tvar tree = {};\n\tvar filecontents = {};\n\n\tstacks.eachStackByStack(function (frames, count) {\n\t\tvar subtree = tree;\n\t\tvar node, i;\n\n\t\tfor (i = 0; i < frames.length; i++) {\n\t\t\tif (!subtree.hasOwnProperty(frames[i]))\n\t\t\t\tsubtree[frames[i]] = {\n\t\t\t\t    svUnique: 0,\n\t\t\t\t    svTotal: 0,\n\t\t\t\t    svChildren: {}\n\t\t\t\t};\n\n\t\t\tnode = subtree[frames[i]];\n\t\t\tnode.svTotal += count;\n\t\t\tsubtree = node.svChildren;\n\t\t}\n\n\t\tnode.svUnique += count;\n\t});\n\n\ttree = {\n\t    '': {\n\t\tsvUnique: 0,\n\t\tsvTotal: Object.keys(tree).reduce(\n\t\t    function (p, c) { return (p + tree[c].svTotal); }, 0),\n\t\tsvChildren: tree\n\t    }\n\t};\n\n\tmod_vasync.forEachParallel({\n\t    'inputs': [ 'icicle.css', 'icicle.js', 'icicle.htm', 'd3.v2.js' ],\n\t    'func': function (filename, stepcb) {\n\t\tvar path = mod_path.join(__dirname, '../share', filename);\n\t\tvar key = filename.replace(/\\./g, '_');\n\t\tmod_fs.readFile(path, function (err, contents) {\n\t\t\tif (err)\n\t\t\t\terr = new VError(err, 'failed to load \"%s\"',\n\t\t\t\t    filename);\n\t\t\telse\n\t\t\t\tfilecontents[key] = contents.toString('utf8');\n\t\t\tstepcb(err);\n\t\t});\n\t    }\n\t}, function (err) {\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tvar compiled, rendered;\n\n\t\tfilecontents['title'] = 'Flame graph';\n\t\tfilecontents['rawdata'] = JSON.stringify(tree, null, '\\t');\n\t\tcompiled = mod_hogan.compile(filecontents['icicle_htm']);\n\t\trendered = compiled.render(filecontents);\n\t\toutput.write(rendered);\n\t\tcallback();\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/output-flamegraph-svg.js":"/*\n * lib/output-flamegraph-svg.js: emits StackSets as Flame Graphs in SVG format.\n * This is a pretty direct port of Brendan Gregg's FlameGraph tool.\n */\n\nvar mod_assert = require('assert');\nvar mod_color = require('./color');\nvar mod_xml = require('./xml');\n\nexports.emit = function emitFlameGraph(args, callback)\n{\n\tvar emitter = new FlameGraphEmitter(args);\n\temitter.run(callback);\n};\n\n/*\n * Arguments:\n *\n *    stacks\t\tStackSet\tStacks to visualize\n *\n *    output\t\tWritableStream\tOutput file\n *\n *    log\t\tBunyan Logger\tLogger\n *\n *    font_face\t\tString\t\tFont face for text\n *    [\"Verdana\"]\n *\n *    font_size \tInteger\t\tFont size for text\n *    [12]\n *\n *    title\t\tString\t\tTitle of graph\n *    [\"Flame Graph\"]\n *\n *    width\t\tInteger\t\tWidth of graph, in pixels\n *    [1200]\n *\n *    frame_height\tInteger\t\tHeight of each frame, in pixels\n *    [16]\n *\n *    min_width\t\tNumber\t\tMinimum width of each frame, in pixels\n *    [0.1]\n *\n *    coloring\t\tString\t\tDefines how to color each box.  Options\n *    [\"time-based\"]\t\t\tcurrently include:\n *\n *\t    \"random\"\t\tEach box gets a random flame-like color.\n *\n *\t    \"gradient\"\t\tEach row gets the same color.  The colors from\n *\t\t\t\tbottom to top form a gradient from dark red to\n *\t\t\t\tyellow.\n *\n *\t    \"time-based\"\tEach row gets the same hue.  Saturation varies\n *\t\t\t\twithin each row according to size (width).\n */\nfunction FlameGraphEmitter(args)\n{\n\tmod_assert.ok(args.stacks && args.stacks.constructor &&\n\t    args.stacks.constructor.name == 'StackSet',\n\t    'required \"stacks\" argument must be a StackSet');\n\tmod_assert.ok(args.output && args.output.write &&\n\t    typeof (args.output.write) == 'function',\n\t    'required \"output\" argument must be a function');\n\tmod_assert.ok(args.log, 'required \"log\" argument must be a logger');\n\n\tif (args.coloring)\n\t\tmod_assert.ok(args.coloring == 'random' ||\n\t\t    args.coloring == 'gradient' ||\n\t\t    args.coloring == 'time-based',\n\t\t    '\"coloring\" must be \"random\", \"gradient\", or \"time-based\"');\n\n\tthis.fge_stacks = args.stacks;\n\tthis.fge_output = args.output;\n\tthis.fge_log = args.log;\n\n\tthis.fge_params = {\n\t    'coloring': args.coloring || 'time-based',\n\t    'font_face': args.font_face || 'Verdana',\n\t    'font_size': Math.floor(args.font_size) || 12,\n\t    'frame_height': Math.floor(args.frame_height) || 16,\n\t    'min_width': parseFloat(args.min_width) || 0.1,\n\t    'title': args.title || 'Flame Graph',\n\t    'width': Math.floor(args.width) || 1200\n\t};\n}\n\nFlameGraphEmitter.prototype.run = function (callback)\n{\n\t/*\n\t * Because the input data comes from a profiler rather than measurements\n\t * at each function entry and exit, the x-axis of our flame graph is not\n\t * meaningful.  We know that a given function (at depth D) invoked\n\t * several other functions (at depth D+1), and we know how long was\n\t * spent in each of these functions, but we don't know in what order\n\t * they were called.  We have to pick an order to present them, so we do\n\t * it alphabetically.  Having done this, one can think of the data as\n\t * though we invoked the alphabetically first function first, then the\n\t * second function next, and so on.  Using this mental model, we say\n\t * that a given frame starts at a given \"time\" (in samples) and lasts\n\t * for a certain \"time\" (also a number of samples).  It's important to\n\t * remember that this doesn't have anything to do with real time, but\n\t * rather the way we're presenting the profiling data.\n\t *\n\t * With this in mind, we process the stacks in order of the above notion\n\t * of time, which is left-to-right in the final flame graph.  The final\n\t * output is fge_boxes, which maps a (frame, depth, end) tuple (which\n\t * uniquely identifies a particular box in the flame graph) to an\n\t * integer indicating when that invocation of that frame started (i.e.\n\t * how wide the box is).  As part of constructing this, we also maintain\n\t * fge_starts, which maps a (frame, depth) tuple to an integer\n\t * indicating the start time for the most recent invocation of this\n\t * frame at this depth.\n\t */\n\tvar flow = this.flow.bind(this);\n\n\tthis.fge_boxes = {};\n\tthis.fge_starts = {};\n\tthis.fge_last = [];\n\tthis.fge_time = 0;\n\tthis.fge_maxdepth = 0;\n\n\t/*\n\t * We keep track of the number of samples at each level of depth for\n\t * coloring purposes.\n\t */\n\tthis.fge_depthsamples = [];\n\n\tthis.fge_stacks.eachStackByStack(flow);\n\tflow([], 0);\n\n\tthis.draw(callback);\n};\n\nFlameGraphEmitter.prototype.flow = function (frames, count)\n{\n\tvar i, nsameframes, starts_key, ends_key;\n\n\t/*\n\t * Prepend an empty frame to every real stack to represent the \"all\n\t * samples\" synthetic frame.  The final invocation with frames == []\n\t * does not correspond to a real stack, but rather causes us to compute\n\t * data for the \"all samples\" frame.\n\t */\n\tif (frames.length !== 0)\n\t\tframes = [''].concat(frames);\n\n\tif (frames.length - 1 > this.fge_maxdepth)\n\t\tthis.fge_maxdepth = frames.length - 1;\n\n\tfor (i = 0; i < this.fge_last.length && i < frames.length; i++) {\n\t\tif (this.fge_last[i] != frames[i])\n\t\t\tbreak;\n\t}\n\n\tnsameframes = i;\n\n\tfor (i = this.fge_last.length - 1; i >= nsameframes; i--) {\n\t\t/*\n\t\t * Each of these frames was present in the previous stack, but\n\t\t * not this one, so we mark them having ended here.\n\t\t */\n\t\tstarts_key = [ this.fge_last[i], i ].join('--');\n\t\tends_key = [ this.fge_last[i], i, this.fge_time ].join('--');\n\t\tthis.fge_boxes[ends_key] = this.fge_starts[starts_key];\n\t\tthis.fge_depthsamples[i] += this.fge_time -\n\t\t    this.fge_starts[starts_key];\n\t\tdelete (this.fge_starts[starts_key]);\n\t}\n\n\tfor (i = nsameframes; i < frames.length; i++) {\n\t\t/*\n\t\t * Each of these frames was not present in the previous stack,\n\t\t * so we mark them having started here.\n\t\t */\n\t\tstarts_key = [ frames[i], i ].join('--');\n\t\tthis.fge_starts[starts_key] = this.fge_time;\n\n\t\tif (this.fge_depthsamples[i] === undefined)\n\t\t\tthis.fge_depthsamples[i] = 0;\n\t}\n\n\tthis.fge_time += count;\n\tthis.fge_last = frames;\n};\n\nFlameGraphEmitter.prototype.color = function (depth, samples)\n{\n\tvar r = 205, rplus = 50;\n\tvar g = 0, gplus = 230;\n\tvar b = 0, bplus = 55;\n\n\tif (this.fge_params['coloring'] == 'random') {\n\t\treturn ('rgb(' + [\n\t\t    r + Math.floor(Math.random() * rplus),\n\t\t    g + Math.floor(Math.random() * gplus),\n\t\t    b + Math.floor(Math.random() + bplus)\n\t\t].join(',') + ')');\n\t}\n\n\tif (this.fge_params['coloring'] == 'gradient') {\n\t\tvar ratio = depth / this.fge_maxdepth;\n\t\treturn ('rgb(' + [\n\t\t    r + Math.floor(ratio * rplus),\n\t\t    g + Math.floor(ratio * gplus),\n\t\t    b + Math.floor(ratio * bplus)\n\t\t].join(',') + ')');\n\t}\n\n\tvar h = 0, hplus = 60;\n\tvar s = 30, splus = 70;\n\tvar v = 80, vplus = 20;\n\n\tvar hratio = depth / this.fge_maxdepth;\n\tvar sratio = samples / this.fge_depthsamples[depth];\n\n\tvar rh = h + hratio * hplus;\n\tvar rs = (s + sratio * splus) / 100;\n\tvar rv = (v + hratio * vplus) / 100;\n\tvar rgb = mod_color.convertHsvToRgb(rh, rs, rv);\n\n\treturn ('rgb(' + rgb.join(',') + ')');\n};\n\nFlameGraphEmitter.prototype.draw = function (callback)\n{\n\tvar xml = new mod_xml.XmlEmitter(this.fge_output);\n\n\tvar fontface = this.fge_params['font_face'];\n\tvar fontsize = this.fge_params['font_size'];\n\n\tvar xpad = 10;\n\tvar ypadtop = fontsize * 4 + fontsize * 2 + 10;\n\tvar ypadbtm = fontsize * 2 + 10;\n\n\tvar width = this.fge_params['width'];\n\tvar widthpersample = (width - 2 * xpad) / this.fge_time;\n\tvar height = this.fge_maxdepth * this.fge_params['frame_height'] +\n\t    ypadtop + ypadbtm;\n\n\tvar black = 'rgb(0, 0, 0)';\n\n\txml.emitDoctype('svg', 'PUBLIC \"-//W3C//DTD SVG 1.1//EN\"',\n\t    'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');\n\n\txml.emitStart('svg', {\n\t    'version': '1.1',\n\t    'width': width,\n\t    'height': height,\n\t    'onload': 'init(evt)',\n\t    'viewBox': [ 0, 0, width, height ].join(' '),\n\t    'xmlns': 'http://www.w3.org/2000/svg'\n\t});\n\n\txml.emitStart('defs');\n\txml.emitStart('linearGradient', {\n\t    'id': 'background',\n\t    'y1': 0,\n\t    'y2': 1,\n\t    'x1': 0,\n\t    'x2': 0\n\t});\n\txml.emitEmpty('stop', { 'stop-color': '#eeeeee', 'offset': '5%' });\n\txml.emitEmpty('stop', { 'stop-color': '#eeeeb0', 'offset': '95%' });\n\txml.emitEnd('linearGradient');\n\txml.emitEnd('defs');\n\n\txml.emitStart('style', { 'type': 'text/css' });\n\txml.emitCData(\n\t    '\trect[rx]:hover { stroke:black; stroke-width:1; }\\n' +\n\t    '\ttext:hover { stroke:black; stroke-width:1; ' +\n\t\t'stroke-opacity:0.35; }\\n'\n\t);\n\txml.emitEnd('style');\n\n\txml.emitStart('script', { 'type': 'text/ecmascript' });\n\txml.emitCData(\n\t    '\tvar details;\\n' +\n\t    '\tfunction init(evt) {\\n' +\n\t    '\t\tdetails = document.getElementById(\"details\").\\n' +\n\t    '\t\t    firstChild;\\n' +\n\t    '\t}\\n' +\n\t    '\tfunction s(info) { details.nodeValue = info; }\\n' +\n\t    '\tfunction c() { details.nodeValue = \" \"; }\\n'\n\t);\n\txml.emitEnd('script');\n\n\temitRectangle(xml, 0, 0, width, height, 'url(#background)', {});\n\n\temitString(xml, black, fontface, fontsize + 5, Math.floor(width / 2),\n\t    fontsize * 2, this.fge_params['title'], 'middle', {});\n\n\temitString(xml, black, fontface, fontsize, xpad,\n\t    ypadtop - ypadbtm, 'Function:', 'left', {});\n\n\temitString(xml, black, fontface, fontsize, xpad + 60,\n\t    ypadtop - ypadbtm, ' ', 'left', { 'id': 'details' });\n\n\tfor (var ident in this.fge_boxes) {\n\t\tvar parts = ident.split('--');\n\t\tvar func = parts[0];\n\t\tvar depth = parseInt(parts[1], 10);\n\t\tvar endtime = parseInt(parts[2], 10);\n\n\t\tvar starttime = this.fge_boxes[ident];\n\t\tvar nsamples = endtime - starttime;\n\n\t\tvar x1 = xpad + starttime * widthpersample;\n\t\tvar x2 = xpad + endtime * widthpersample;\n\t\tvar boxwidth = x2 - x1;\n\n\t\tif (boxwidth < this.fge_params['min_width'])\n\t\t\tcontinue;\n\n\t\tvar y1 = height - ypadbtm - (depth + 1) *\n\t\t    this.fge_params['frame_height'] + 1;\n\t\tvar y2 = height - ypadbtm - depth *\n\t\t    this.fge_params['frame_height'];\n\n\t\tvar info;\n\t\tif (func.length === 0 && depth === 0) {\n\t\t\tinfo = 'all samples (' + nsamples + ' samples, 100%)';\n\t\t} else {\n\t\t\tvar pct = ((100 * nsamples) / this.fge_time).toFixed(2);\n\t\t\tinfo = func + ' (' + nsamples + ' samples, ' +\n\t\t\t    pct + '%)';\n\t\t}\n\n\t\tvar color = this.color(depth, nsamples);\n\n\t\temitRectangle(xml, x1, y1, x2, y2, color, {\n\t\t    'rx': 2,\n\t\t    'ry': 2,\n\t\t    'onmouseover': 's(\"' + info + '\")',\n\t\t    'onmouseout': 'c()'\n\t\t});\n\n\t\tif (boxwidth > 50) {\n\t\t\tvar nchars = Math.floor(boxwidth / (0.7 * fontsize));\n\n\t\t\tvar text;\n\t\t\tif (nchars < func.length)\n\t\t\t\ttext = func.substr(0, nchars) + '..';\n\t\t\telse\n\t\t\t\ttext = func;\n\n\t\t\temitString(xml, black, fontface, fontsize, x1 + 3,\n\t\t\t    3 + (y1 + y2) / 2, text, 'left', {\n\t\t\t\t'onmouseover': 's(\"' + info + '\")',\n\t\t\t\t'onmouseout': 'c()'\n\t\t\t    });\n\t\t}\n\t}\n\n\txml.emitEnd('svg');\n\n\t/*\n\t * XXX It's a little disingenuous to invoke the callback now because we\n\t * don't actually know whether our output has been successfully written\n\t * or just buffered inside node.  We really should implement flow\n\t * control here by keeping track of how many rectangles we've emitted,\n\t * and if we find that our output has been buffered, we simply stop\n\t * until the underlying stream emits \"drain\", at which point we pick up\n\t * where we left off.\n\t */\n\tcallback();\n};\n\nfunction emitRectangle(xml, x1, y1, x2, y2, fill, extra)\n{\n\tvar attrs = {\n\t    'x': x1.toFixed(1),\n\t    'y': y1.toFixed(1),\n\t    'width': (x2 - x1).toFixed(1),\n\t    'height': (y2 - y1).toFixed(1),\n\t    'fill': fill\n\t};\n\n\tfor (var key in extra)\n\t\tattrs[key] = extra[key];\n\n\txml.emitEmpty('rect', attrs);\n}\n\nfunction emitString(xml, color, font, size, x, y, str, loc, extra)\n{\n\tvar attrs = {\n\t    'text-anchor': loc,\n\t    'x': x,\n\t    'y': y,\n\t    'font-size': size,\n\t    'font-family': font,\n\t    'fill': color\n\t};\n\n\tfor (var key in extra)\n\t\tattrs[key] = extra[key];\n\n\txml.emitStart('text', attrs, { 'bare': true });\n\txml.emitCData(str);\n\txml.emitEnd('text', { 'bare': true });\n}\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/lib/xml.js":"/*\n * lib/xml.js: XML utility routines\n */\n\nvar mod_assert = require('assert');\n\nexports.XmlEmitter = XmlEmitter;\n\n/*\n * Basic interface for emitting well-formed XML. This isn't bulletproof, but it\n * does escape values (not tags or keys) and checks for basic errors.\n */\nfunction XmlEmitter(stream)\n{\n\tthis.xe_stream = stream;\n\tthis.xe_stack = [];\n}\n\nXmlEmitter.prototype.emitDoctype = function (name, type, path)\n{\n\tthis.xe_stream.write('<?xml version=\"1.0\"?>\\n');\n\tthis.xe_stream.write('<!DOCTYPE ' + name + ' ' + type + ' \"' +\n\t    path + '\">\\n');\n};\n\nXmlEmitter.prototype.escape = function (str)\n{\n\t/* BEGIN JSSTYLED */\n\treturn (str.toString().replace(/&/g, '&amp;').\n\t    replace(/</g, '&lt;').\n\t    replace(/>/g, '&gt;').\n\t    replace(/\"/g, '&quot;'));\n\t/* END JSSTYLED */\n};\n\nXmlEmitter.prototype.emitIndent = function ()\n{\n\tvar str = '';\n\tvar i;\n\n\tfor (i = 0; i < this.xe_stack.length; i++)\n\t\tstr += '    ';\n\n\tthis.xe_stream.write(str);\n};\n\nXmlEmitter.prototype.emitEmpty = function (name, attrs)\n{\n\tthis.emitIndent();\n\tthis.xe_stream.write('<' + name + ' ');\n\tthis.emitAttrs(attrs);\n\tthis.xe_stream.write('/>\\n');\n};\n\nXmlEmitter.prototype.emitAttrs = function (attrs)\n{\n\tvar key;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (key in attrs)\n\t\tthis.xe_stream.write(key + '=\\\"' +\n\t\t    this.escape(attrs[key]) + '\\\" ');\n};\n\nXmlEmitter.prototype.emitStart = function (name, attrs, opts)\n{\n\tthis.emitIndent();\n\tthis.xe_stack.push(name);\n\n\tthis.xe_stream.write('<' + name + ' ');\n\tthis.emitAttrs(attrs);\n\tthis.xe_stream.write('>');\n\n\tif (!opts || !opts['bare'])\n\t\tthis.xe_stream.write('\\n');\n};\n\nXmlEmitter.prototype.emitEnd = function (name, opts)\n{\n\tvar check = this.xe_stack.pop();\n\n\tmod_assert.equal(name, check);\n\n\tif (!opts || !opts['bare'])\n\t\tthis.emitIndent();\n\n\tthis.xe_stream.write('</' + name + '>\\n');\n};\n\nXmlEmitter.prototype.emitCData = function (data)\n{\n\tthis.xe_stream.write(this.escape(data));\n};\n\nXmlEmitter.prototype.emitComment = function (content)\n{\n\tthis.xe_stream.write('<!-- ' + content + ' -->\\n');\n};\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/share/d3.v2.js":"(function(){if (!Date.now) Date.now = function() {\n  return +new Date;\n};\ntry {\n  document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\n} catch (error) {\n  var d3_style_prototype = CSSStyleDeclaration.prototype,\n      d3_style_setProperty = d3_style_prototype.setProperty;\n  d3_style_prototype.setProperty = function(name, value, priority) {\n    d3_style_setProperty.call(this, name, value + \"\", priority);\n  };\n}\nd3 = {version: \"2.8.1\"}; // semver\nfunction d3_class(ctor, properties) {\n  try {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  } catch (e) {\n    ctor.prototype = properties;\n  }\n}\nvar d3_array = d3_arraySlice; // conversion for NodeLists\n\nfunction d3_arrayCopy(pseudoarray) {\n  var i = -1, n = pseudoarray.length, array = [];\n  while (++i < n) array.push(pseudoarray[i]);\n  return array;\n}\n\nfunction d3_arraySlice(pseudoarray) {\n  return Array.prototype.slice.call(pseudoarray);\n}\n\ntry {\n  d3_array(document.documentElement.childNodes)[0].nodeType;\n} catch(e) {\n  d3_array = d3_arrayCopy;\n}\n\nvar d3_arraySubclass = [].__proto__?\n\n// Until ECMAScript supports array subclassing, prototype injection works well.\nfunction(array, prototype) {\n  array.__proto__ = prototype;\n}:\n\n// And if your browser doesn't support __proto__, we'll use direct extension.\nfunction(array, prototype) {\n  for (var property in prototype) array[property] = prototype[property];\n};\nd3.map = function(object) {\n  var map = new d3_Map;\n  for (var key in object) map.set(key, object[key]);\n  return map;\n};\n\nfunction d3_Map() {}\n\nd3_class(d3_Map, {\n  has: function(key) {\n    return d3_map_prefix + key in this;\n  },\n  get: function(key) {\n    return this[d3_map_prefix + key];\n  },\n  set: function(key, value) {\n    return this[d3_map_prefix + key] = value;\n  },\n  remove: function(key) {\n    key = d3_map_prefix + key;\n    return key in this && delete this[key];\n  },\n  keys: function() {\n    var keys = [];\n    this.forEach(function(key) { keys.push(key); });\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    this.forEach(function(key, value) { values.push(value); });\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    this.forEach(function(key, value) { entries.push({key: key, value: value}); });\n    return entries;\n  },\n  forEach: function(f) {\n    for (var key in this) {\n      if (key.charCodeAt(0) === d3_map_prefixCode) {\n        f.call(this, key.substring(1), this[key]);\n      }\n    }\n  }\n});\n\nvar d3_map_prefix = \"\\0\", // prevent collision with built-ins\n    d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\nfunction d3_this() {\n  return this;\n}\nd3.functor = function(v) {\n  return typeof v === \"function\" ? v : function() { return v; };\n};\n// Copies a variable number of methods from source to target.\nd3.rebind = function(target, source) {\n  var i = 1, n = arguments.length, method;\n  while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n  return target;\n};\n\n// Method is assumed to be a standard D3 getter-setter:\n// If passed with no arguments, gets the value.\n// If passed with arguments, sets the value and returns the target.\nfunction d3_rebind(target, source, method) {\n  return function() {\n    var value = method.apply(source, arguments);\n    return arguments.length ? target : value;\n  };\n}\nd3.ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\nd3.descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\nd3.mean = function(array, f) {\n  var n = array.length,\n      a,\n      m = 0,\n      i = -1,\n      j = 0;\n  if (arguments.length === 1) {\n    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\n  } else {\n    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\n  }\n  return j ? m : undefined;\n};\nd3.median = function(array, f) {\n  if (arguments.length > 1) array = array.map(f);\n  array = array.filter(d3_number);\n  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;\n};\nd3.min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n  }\n  return a;\n};\nd3.max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n  }\n  return a;\n};\nd3.extent = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b,\n      c;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  } else {\n    while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  }\n  return [a, c];\n};\nd3.random = {\n  normal: function(mean, deviation) {\n    if (arguments.length < 2) deviation = 1;\n    if (arguments.length < 1) mean = 0;\n    return function() {\n      var x, y, r;\n      do {\n        x = Math.random() * 2 - 1;\n        y = Math.random() * 2 - 1;\n        r = x * x + y * y;\n      } while (!r || r > 1);\n      return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n};\nfunction d3_number(x) {\n  return x != null && !isNaN(x);\n}\nd3.sum = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1;\n\n  if (arguments.length === 1) {\n    while (++i < n) if (!isNaN(a = +array[i])) s += a;\n  } else {\n    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\n  }\n\n  return s;\n};\n// R-7 per <http://en.wikipedia.org/wiki/Quantile>\nd3.quantile = function(values, p) {\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = values[h - 1],\n      e = H - h;\n  return e ? v + e * (values[h] - v) : v;\n};\nd3.transpose = function(matrix) {\n  return d3.zip.apply(d3, matrix);\n};\nd3.zip = function() {\n  if (!(n = arguments.length)) return [];\n  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {\n    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {\n      zip[j] = arguments[j][i];\n    }\n  }\n  return zips;\n};\n\nfunction d3_zipLength(d) {\n  return d.length;\n}\nd3.bisector = function(f) {\n  return {\n    left: function(a, x, lo, hi) {\n      if (arguments.length < 3) lo = 0;\n      if (arguments.length < 4) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >> 1;\n        if (f.call(a, a[mid], mid) < x) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (arguments.length < 3) lo = 0;\n      if (arguments.length < 4) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >> 1;\n        if (x < f.call(a, a[mid], mid)) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nvar d3_bisector = d3.bisector(function(d) { return d; });\nd3.bisectLeft = d3_bisector.left;\nd3.bisect = d3.bisectRight = d3_bisector.right;\nd3.first = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) > 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.last = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) <= 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.nest = function() {\n  var nest = {},\n      keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup;\n\n  function map(array, depth) {\n    if (depth >= keys.length) return rollup\n        ? rollup.call(nest, array) : (sortValues\n        ? array.sort(sortValues)\n        : array);\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        object,\n        valuesByKey = new d3_Map,\n        values,\n        o = {};\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n        values.push(object);\n      } else {\n        valuesByKey.set(keyValue, [object]);\n      }\n    }\n\n    valuesByKey.forEach(function(keyValue) {\n      o[keyValue] = map(valuesByKey.get(keyValue), depth);\n    });\n\n    return o;\n  }\n\n  function entries(map, depth) {\n    if (depth >= keys.length) return map;\n\n    var a = [],\n        sortKey = sortKeys[depth++],\n        key;\n\n    for (key in map) {\n      a.push({key: key, values: entries(map[key], depth)});\n    }\n\n    if (sortKey) a.sort(function(a, b) {\n      return sortKey(a.key, b.key);\n    });\n\n    return a;\n  }\n\n  nest.map = function(array) {\n    return map(array, 0);\n  };\n\n  nest.entries = function(array) {\n    return entries(map(array, 0), 0);\n  };\n\n  nest.key = function(d) {\n    keys.push(d);\n    return nest;\n  };\n\n  // Specifies the order for the most-recently specified key.\n  // Note: only applies to entries. Map keys are unordered!\n  nest.sortKeys = function(order) {\n    sortKeys[keys.length - 1] = order;\n    return nest;\n  };\n\n  // Specifies the order for leaf values.\n  // Applies to both maps and entries array.\n  nest.sortValues = function(order) {\n    sortValues = order;\n    return nest;\n  };\n\n  nest.rollup = function(f) {\n    rollup = f;\n    return nest;\n  };\n\n  return nest;\n};\nd3.keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\nd3.values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\nd3.entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\nd3.permute = function(array, indexes) {\n  var permutes = [],\n      i = -1,\n      n = indexes.length;\n  while (++i < n) permutes[i] = array[indexes[i]];\n  return permutes;\n};\nd3.merge = function(arrays) {\n  return Array.prototype.concat.apply([], arrays);\n};\nd3.split = function(array, f) {\n  var arrays = [],\n      values = [],\n      value,\n      i = -1,\n      n = array.length;\n  if (arguments.length < 2) f = d3_splitter;\n  while (++i < n) {\n    if (f.call(values, value = array[i], i)) {\n      values = [];\n    } else {\n      if (!values.length) arrays.push(values);\n      values.push(value);\n    }\n  }\n  return arrays;\n};\n\nfunction d3_splitter(d) {\n  return d == null;\n}\nfunction d3_collapse(s) {\n  return s.replace(/(^\\s+)|(\\s+$)/g, \"\").replace(/\\s+/g, \" \");\n}\nd3.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       k = d3_range_integerScale(Math.abs(step)),\n       i = -1,\n       j;\n  start *= k, stop *= k, step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n  else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n};\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\nd3.requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\nd3.round = function(x, n) {\n  return n\n      ? Math.round(x * (n = Math.pow(10, n))) / n\n      : Math.round(x);\n};\nd3.xhr = function(url, mime, callback) {\n  var req = new XMLHttpRequest;\n  if (arguments.length < 3) callback = mime, mime = null;\n  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);\n  req.open(\"GET\", url, true);\n  if (mime) req.setRequestHeader(\"Accept\", mime);\n  req.onreadystatechange = function() {\n    if (req.readyState === 4) callback(req.status < 300 ? req : null);\n  };\n  req.send(null);\n};\nd3.text = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseText);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.json = function(url, callback) {\n  d3.text(url, \"application/json\", function(text) {\n    callback(text ? JSON.parse(text) : null);\n  });\n};\nd3.html = function(url, callback) {\n  d3.text(url, \"text/html\", function(text) {\n    if (text != null) { // Treat empty string as valid HTML.\n      var range = document.createRange();\n      range.selectNode(document.body);\n      text = range.createContextualFragment(text);\n    }\n    callback(text);\n  });\n};\nd3.xml = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseXML);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nvar d3_nsPrefix = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nd3.ns = {\n  prefix: d3_nsPrefix,\n  qualify: function(name) {\n    var i = name.indexOf(\":\"),\n        prefix = name;\n    if (i >= 0) {\n      prefix = name.substring(0, i);\n      name = name.substring(i + 1);\n    }\n    return d3_nsPrefix.hasOwnProperty(prefix)\n        ? {space: d3_nsPrefix[prefix], local: name}\n        : name;\n  }\n};\nd3.dispatch = function() {\n  var dispatch = new d3_dispatch,\n      i = -1,\n      n = arguments.length;\n  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n  return dispatch;\n};\n\nfunction d3_dispatch() {}\n\nd3_dispatch.prototype.on = function(type, listener) {\n  var i = type.indexOf(\".\"),\n      name = \"\";\n\n  // Extract optional namespace, e.g., \"click.foo\"\n  if (i > 0) {\n    name = type.substring(i + 1);\n    type = type.substring(0, i);\n  }\n\n  return arguments.length < 2\n      ? this[type].on(name)\n      : this[type].on(name, listener);\n};\n\nfunction d3_dispatch_event(dispatch) {\n  var listeners = [],\n      listenerByName = new d3_Map;\n\n  function event() {\n    var z = listeners, // defensive reference\n        i = -1,\n        n = z.length,\n        l;\n    while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n    return dispatch;\n  }\n\n  event.on = function(name, listener) {\n    var l = listenerByName.get(name),\n        i;\n\n    // return the current listener, if any\n    if (arguments.length < 2) return l && l.on;\n\n    // remove the old listener, if any (with copy-on-write)\n    if (l) {\n      l.on = null;\n      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n      listenerByName.remove(name);\n    }\n\n    // add the new listener, if any\n    if (listener) listeners.push(listenerByName.set(name, {on: listener}));\n\n    return dispatch;\n  };\n\n  return event;\n}\n// TODO align\nd3.format = function(specifier) {\n  var match = d3_format_re.exec(specifier),\n      fill = match[1] || \" \",\n      sign = match[3] || \"\",\n      zfill = match[5],\n      width = +match[6],\n      comma = match[7],\n      precision = match[8],\n      type = match[9],\n      scale = 1,\n      suffix = \"\",\n      integer = false;\n\n  if (precision) precision = +precision.substring(1);\n\n  if (zfill) {\n    fill = \"0\"; // TODO align = \"=\";\n    if (comma) width -= Math.floor((width - 1) / 4);\n  }\n\n  switch (type) {\n    case \"n\": comma = true; type = \"g\"; break;\n    case \"%\": scale = 100; suffix = \"%\"; type = \"f\"; break;\n    case \"p\": scale = 100; suffix = \"%\"; type = \"r\"; break;\n    case \"d\": integer = true; precision = 0; break;\n    case \"s\": scale = -1; type = \"r\"; break;\n  }\n\n  // If no precision is specified for r, fallback to general notation.\n  if (type == \"r\" && !precision) type = \"g\";\n\n  type = d3_format_types.get(type) || d3_format_typeDefault;\n\n  return function(value) {\n\n    // Return the empty string for floats formatted as ints.\n    if (integer && (value % 1)) return \"\";\n\n    // Convert negative to positive, and record the sign prefix.\n    var negative = (value < 0) && (value = -value) ? \"\\u2212\" : sign;\n\n    // Apply the scale, computing it from the value's exponent for si format.\n    if (scale < 0) {\n      var prefix = d3.formatPrefix(value, precision);\n      value *= prefix.scale;\n      suffix = prefix.symbol;\n    } else {\n      value *= scale;\n    }\n\n    // Convert to the desired precision.\n    value = type(value, precision);\n\n    // If the fill character is 0, the sign and group is applied after the fill.\n    if (zfill) {\n      var length = value.length + negative.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n    }\n\n    // Otherwise (e.g., space-filling), the sign and group is applied before.\n    else {\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n      var length = value.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n    }\n\n    return value + suffix;\n  };\n};\n\n// [[fill]align][sign][#][0][width][,][.precision][type]\nvar d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n\nvar d3_format_types = d3.map({\n  g: function(x, p) { return x.toPrecision(p); },\n  e: function(x, p) { return x.toExponential(p); },\n  f: function(x, p) { return x.toFixed(p); },\n  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }\n});\n\nfunction d3_format_precision(x, p) {\n  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);\n}\n\nfunction d3_format_typeDefault(x) {\n  return x + \"\";\n}\n\n// Apply comma grouping for thousands.\nfunction d3_format_group(value) {\n  var i = value.lastIndexOf(\".\"),\n      f = i >= 0 ? value.substring(i) : (i = value.length, \"\"),\n      t = [];\n  while (i > 0) t.push(value.substring(i -= 3, i + 3));\n  return t.reverse().join(\",\") + f;\n}\nvar d3_formatPrefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"].map(d3_formatPrefix);\n\nd3.formatPrefix = function(value, precision) {\n  var i = 0;\n  if (value) {\n    if (value < 0) value *= -1;\n    if (precision) value = d3.round(value, d3_format_precision(value, precision));\n    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n  }\n  return d3_formatPrefixes[8 + i / 3];\n};\n\nfunction d3_formatPrefix(d, i) {\n  return {\n    scale: Math.pow(10, (8 - i) * 3),\n    symbol: d\n  };\n}\n\n/*\n * TERMS OF USE - EASING EQUATIONS\n *\n * Open source under the BSD License.\n *\n * Copyright 2001 Robert Penner\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of contributors may be used to\n *   endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar d3_ease_quad = d3_ease_poly(2),\n    d3_ease_cubic = d3_ease_poly(3),\n    d3_ease_default = function() { return d3_ease_identity; };\n\nvar d3_ease = d3.map({\n  linear: d3_ease_default,\n  poly: d3_ease_poly,\n  quad: function() { return d3_ease_quad; },\n  cubic: function() { return d3_ease_cubic; },\n  sin: function() { return d3_ease_sin; },\n  exp: function() { return d3_ease_exp; },\n  circle: function() { return d3_ease_circle; },\n  elastic: d3_ease_elastic,\n  back: d3_ease_back,\n  bounce: function() { return d3_ease_bounce; }\n});\n\nvar d3_ease_mode = d3.map({\n  \"in\": d3_ease_identity,\n  \"out\": d3_ease_reverse,\n  \"in-out\": d3_ease_reflect,\n  \"out-in\": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }\n});\n\nd3.ease = function(name) {\n  var i = name.indexOf(\"-\"),\n      t = i >= 0 ? name.substring(0, i) : name,\n      m = i >= 0 ? name.substring(i + 1) : \"in\";\n  t = d3_ease.get(t) || d3_ease_default;\n  m = d3_ease_mode.get(m) || d3_ease_identity;\n  return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));\n};\n\nfunction d3_ease_clamp(f) {\n  return function(t) {\n    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n  };\n}\n\nfunction d3_ease_reverse(f) {\n  return function(t) {\n    return 1 - f(1 - t);\n  };\n}\n\nfunction d3_ease_reflect(f) {\n  return function(t) {\n    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n  };\n}\n\nfunction d3_ease_identity(t) {\n  return t;\n}\n\nfunction d3_ease_poly(e) {\n  return function(t) {\n    return Math.pow(t, e);\n  };\n}\n\nfunction d3_ease_sin(t) {\n  return 1 - Math.cos(t * Math.PI / 2);\n}\n\nfunction d3_ease_exp(t) {\n  return Math.pow(2, 10 * (t - 1));\n}\n\nfunction d3_ease_circle(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction d3_ease_elastic(a, p) {\n  var s;\n  if (arguments.length < 2) p = 0.45;\n  if (arguments.length < 1) { a = 1; s = p / 4; }\n  else s = p / (2 * Math.PI) * Math.asin(1 / a);\n  return function(t) {\n    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);\n  };\n}\n\nfunction d3_ease_back(s) {\n  if (!s) s = 1.70158;\n  return function(t) {\n    return t * t * ((s + 1) * t - s);\n  };\n}\n\nfunction d3_ease_bounce(t) {\n  return t < 1 / 2.75 ? 7.5625 * t * t\n      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75\n      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375\n      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n}\nd3.event = null;\n\nfunction d3_eventCancel() {\n  d3.event.stopPropagation();\n  d3.event.preventDefault();\n}\n\nfunction d3_eventSource() {\n  var e = d3.event, s;\n  while (s = e.sourceEvent) e = s;\n  return e;\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3_eventDispatch(target) {\n  var dispatch = new d3_dispatch,\n      i = 0,\n      n = arguments.length;\n\n  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n  // Creates a dispatch context for the specified `thiz` (typically, the target\n  // DOM element that received the source event) and `argumentz` (typically, the\n  // data `d` and index `i` of the target element). The returned function can be\n  // used to dispatch an event to any registered listeners; the function takes a\n  // single argument as input, being the event to dispatch. The event must have\n  // a \"type\" attribute which corresponds to a type registered in the\n  // constructor. This context will automatically populate the \"sourceEvent\" and\n  // \"target\" attributes of the event, as well as setting the `d3.event` global\n  // for the duration of the notification.\n  dispatch.of = function(thiz, argumentz) {\n    return function(e1) {\n      try {\n        var e0 =\n        e1.sourceEvent = d3.event;\n        e1.target = target;\n        d3.event = e1;\n        dispatch[e1.type].apply(thiz, argumentz);\n      } finally {\n        d3.event = e0;\n      }\n    };\n  };\n\n  return dispatch;\n}\nd3.interpolate = function(a, b) {\n  var i = d3.interpolators.length, f;\n  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n  return f;\n};\n\nd3.interpolateNumber = function(a, b) {\n  b -= a;\n  return function(t) { return a + b * t; };\n};\n\nd3.interpolateRound = function(a, b) {\n  b -= a;\n  return function(t) { return Math.round(a + b * t); };\n};\n\nd3.interpolateString = function(a, b) {\n  var m, // current match\n      i, // current index\n      j, // current index (for coallescing)\n      s0 = 0, // start index of current string prefix\n      s1 = 0, // end index of current string prefix\n      s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n, // q.length\n      o;\n\n  // Reset our regular expression!\n  d3_interpolate_number.lastIndex = 0;\n\n  // Find all numbers in b.\n  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\n    if (m.index) s.push(b.substring(s0, s1 = m.index));\n    q.push({i: s.length, x: m[0]});\n    s.push(null);\n    s0 = d3_interpolate_number.lastIndex;\n  }\n  if (s0 < b.length) s.push(b.substring(s0));\n\n  // Find all numbers in a.\n  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\n    o = q[i];\n    if (o.x == m[0]) { // The numbers match, so coallesce.\n      if (o.i) {\n        if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i - 1] += o.x;\n          s.splice(o.i, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i - 1] += o.x + s[o.i + 1];\n          s.splice(o.i, 2);\n          for (j = i + 1; j < n; ++j) q[j].i -= 2;\n        }\n      } else {\n          if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i] = o.x;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i] = o.x + s[o.i + 1];\n          s.splice(o.i + 1, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        }\n      }\n      q.splice(i, 1);\n      n--;\n      i--;\n    } else {\n      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n    }\n  }\n\n  // Remove any numbers in b not found in a.\n  while (i < n) {\n    o = q.pop();\n    if (s[o.i + 1] == null) { // This match is followed by another number.\n      s[o.i] = o.x;\n    } else { // This match is followed by a string, so coallesce twice.\n      s[o.i] = o.x + s[o.i + 1];\n      s.splice(o.i + 1, 1);\n    }\n    n--;\n  }\n\n  // Special optimization for only a single match.\n  if (s.length === 1) {\n    return s[0] == null ? q[0].x : function() { return b; };\n  }\n\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return function(t) {\n    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateTransform = function(a, b) {\n  var s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n,\n      A = d3.transform(a),\n      B = d3.transform(b),\n      ta = A.translate,\n      tb = B.translate,\n      ra = A.rotate,\n      rb = B.rotate,\n      wa = A.skew,\n      wb = B.skew,\n      ka = A.scale,\n      kb = B.scale;\n\n  if (ta[0] != tb[0] || ta[1] != tb[1]) {\n    s.push(\"translate(\", null, \",\", null, \")\");\n    q.push({i: 1, x: d3.interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3.interpolateNumber(ta[1], tb[1])});\n  } else if (tb[0] || tb[1]) {\n    s.push(\"translate(\" + tb + \")\");\n  } else {\n    s.push(\"\");\n  }\n\n  if (ra != rb) {\n    q.push({i: s.push(s.pop() + \"rotate(\", null, \")\") - 2, x: d3.interpolateNumber(ra, rb)});\n  } else if (rb) {\n    s.push(s.pop() + \"rotate(\" + rb + \")\");\n  }\n\n  if (wa != wb) {\n    q.push({i: s.push(s.pop() + \"skewX(\", null, \")\") - 2, x: d3.interpolateNumber(wa, wb)});\n  } else if (wb) {\n    s.push(s.pop() + \"skewX(\" + wb + \")\");\n  }\n\n  if (ka[0] != kb[0] || ka[1] != kb[1]) {\n    n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\n    q.push({i: n - 4, x: d3.interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3.interpolateNumber(ka[1], kb[1])});\n  } else if (kb[0] != 1 || kb[1] != 1) {\n    s.push(s.pop() + \"scale(\" + kb + \")\");\n  }\n\n  n = q.length;\n  return function(t) {\n    var i = -1, o;\n    while (++i < n) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateRgb = function(a, b) {\n  a = d3.rgb(a);\n  b = d3.rgb(b);\n  var ar = a.r,\n      ag = a.g,\n      ab = a.b,\n      br = b.r - ar,\n      bg = b.g - ag,\n      bb = b.b - ab;\n  return function(t) {\n    return \"#\"\n        + d3_rgb_hex(Math.round(ar + br * t))\n        + d3_rgb_hex(Math.round(ag + bg * t))\n        + d3_rgb_hex(Math.round(ab + bb * t));\n  };\n};\n\n// interpolates HSL space, but outputs RGB string (for compatibility)\nd3.interpolateHsl = function(a, b) {\n  a = d3.hsl(a);\n  b = d3.hsl(b);\n  var h0 = a.h,\n      s0 = a.s,\n      l0 = a.l,\n      h1 = b.h - h0,\n      s1 = b.s - s0,\n      l1 = b.l - l0;\n  return function(t) {\n    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();\n  };\n};\n\nd3.interpolateArray = function(a, b) {\n  var x = [],\n      c = [],\n      na = a.length,\n      nb = b.length,\n      n0 = Math.min(a.length, b.length),\n      i;\n  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n  for (; i < na; ++i) c[i] = a[i];\n  for (; i < nb; ++i) c[i] = b[i];\n  return function(t) {\n    for (i = 0; i < n0; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nd3.interpolateObject = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n  for (k in a) {\n    if (k in b) {\n      i[k] = d3_interpolateByName(k)(a[k], b[k]);\n    } else {\n      c[k] = a[k];\n    }\n  }\n  for (k in b) {\n    if (!(k in a)) {\n      c[k] = b[k];\n    }\n  }\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n}\n\nvar d3_interpolate_number = /[-+]?(?:\\d*\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\n\nfunction d3_interpolateByName(n) {\n  return n == \"transform\"\n      ? d3.interpolateTransform\n      : d3.interpolate;\n}\n\nd3.interpolators = [\n  d3.interpolateObject,\n  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },\n  function(a, b) { return (typeof a === \"string\" || typeof b === \"string\") && d3.interpolateString(a + \"\", b + \"\"); },\n  function(a, b) { return (typeof b === \"string\" ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(a, b); },\n  function(a, b) { return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b); }\n];\nfunction d3_uninterpolateNumber(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return (x - a) * b; };\n}\n\nfunction d3_uninterpolateClamp(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };\n}\nd3.rgb = function(r, g, b) {\n  return arguments.length === 1\n      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)\n      : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb))\n      : d3_rgb(~~r, ~~g, ~~b);\n};\n\nfunction d3_rgb(r, g, b) {\n  return new d3_Rgb(r, g, b);\n}\n\nfunction d3_Rgb(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n}\n\nd3_Rgb.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  var r = this.r,\n      g = this.g,\n      b = this.b,\n      i = 30;\n  if (!r && !g && !b) return d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return d3_rgb(\n      Math.min(255, Math.floor(r / k)),\n      Math.min(255, Math.floor(g / k)),\n      Math.min(255, Math.floor(b / k)));\n};\n\nd3_Rgb.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_rgb(\n      Math.floor(k * this.r),\n      Math.floor(k * this.g),\n      Math.floor(k * this.b));\n};\n\nd3_Rgb.prototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\n\nd3_Rgb.prototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 0x10\n      ? \"0\" + Math.max(0, v).toString(16)\n      : Math.min(255, v).toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0, // red channel; int in [0, 255]\n      g = 0, // green channel; int in [0, 255]\n      b = 0, // blue channel; int in [0, 255]\n      m1, // CSS color specification match\n      m2, // CSS color specification type (e.g., rgb)\n      name;\n\n  /* Handle hsl, rgb. */\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\": {\n        return hsl(\n          parseFloat(m2[0]), // degrees\n          parseFloat(m2[1]) / 100, // percentage\n          parseFloat(m2[2]) / 100 // percentage\n        );\n      }\n      case \"rgb\": {\n        return rgb(\n          d3_rgb_parseNumber(m2[0]),\n          d3_rgb_parseNumber(m2[1]),\n          d3_rgb_parseNumber(m2[2])\n        );\n      }\n    }\n  }\n\n  /* Named colors. */\n  if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);\n\n  /* Hexadecimal colors: #rgb and #rrggbb. */\n  if (format != null && format.charAt(0) === \"#\") {\n    if (format.length === 4) {\n      r = format.charAt(1); r += r;\n      g = format.charAt(2); g += g;\n      b = format.charAt(3); b += b;\n    } else if (format.length === 7) {\n      r = format.substring(1, 3);\n      g = format.substring(3, 5);\n      b = format.substring(5, 7);\n    }\n    r = parseInt(r, 16);\n    g = parseInt(g, 16);\n    b = parseInt(b, 16);\n  }\n\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n      max = Math.max(r, g, b),\n      d = max - min,\n      h,\n      s,\n      l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    s = h = 0;\n  }\n  return d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_parseNumber(c) { // either integer or percentage\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\n\nvar d3_rgb_names = d3.map({\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n});\n\nd3_rgb_names.forEach(function(key, value) {\n  d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));\n});\nd3.hsl = function(h, s, l) {\n  return arguments.length === 1\n      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)\n      : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl))\n      : d3_hsl(+h, +s, +l);\n};\n\nfunction d3_hsl(h, s, l) {\n  return new d3_Hsl(h, s, l);\n}\n\nfunction d3_Hsl(h, s, l) {\n  this.h = h;\n  this.s = s;\n  this.l = l;\n}\n\nd3_Hsl.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, this.l / k);\n};\n\nd3_Hsl.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, k * this.l);\n};\n\nd3_Hsl.prototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nd3_Hsl.prototype.toString = function() {\n  return this.rgb().toString();\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1,\n      m2;\n\n  /* Some simple corrections for h, s and l. */\n  h = h % 360; if (h < 0) h += 360;\n  s = s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n\n  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nfunction d3_selection(groups) {\n  d3_arraySubclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectRoot = document.documentElement,\n    d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,\n    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0]; };\n  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nvar d3_selectionPrototype = [];\n\nd3.selection = function() {\n  return d3_selectionRoot;\n};\n\nd3.selection.prototype = d3_selectionPrototype;\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return function() {\n    return d3_select(selector, this);\n  };\n}\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return function() {\n    return d3_selectAll(selector, this);\n  };\n}\nd3_selectionPrototype.attr = function(name, value) {\n  name = d3.ns.qualify(name);\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) {\n    var node = this.node();\n    return name.local\n        ? node.getAttributeNS(name.space, name.local)\n        : node.getAttribute(name);\n  }\n\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return this.each(value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant)));\n};\nd3_selectionPrototype.classed = function(name, value) {\n  var names = name.split(d3_selection_classedWhitespace),\n      n = names.length,\n      i = -1;\n  if (arguments.length > 1) {\n    while (++i < n) d3_selection_classed.call(this, names[i], value);\n    return this;\n  } else {\n    while (++i < n) if (!d3_selection_classed.call(this, names[i])) return false;\n    return true;\n  }\n};\n\nvar d3_selection_classedWhitespace = /\\s+/g;\n\nfunction d3_selection_classed(name, value) {\n  var re = new RegExp(\"(^|\\\\s+)\" + d3.requote(name) + \"(\\\\s+|$)\", \"g\");\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) {\n    var node = this.node();\n    if (c = node.classList) return c.contains(name);\n    var c = node.className;\n    re.lastIndex = 0;\n    return re.test(c.baseVal != null ? c.baseVal : c);\n  }\n\n  function classedAdd() {\n    if (c = this.classList) return c.add(name);\n    var c = this.className,\n        cb = c.baseVal != null,\n        cv = cb ? c.baseVal : c;\n    re.lastIndex = 0;\n    if (!re.test(cv)) {\n      cv = d3_collapse(cv + \" \" + name);\n      if (cb) c.baseVal = cv;\n      else this.className = cv;\n    }\n  }\n\n  function classedRemove() {\n    if (c = this.classList) return c.remove(name);\n    var c = this.className,\n        cb = c.baseVal != null,\n        cv = cb ? c.baseVal : c;\n    cv = d3_collapse(cv.replace(re, \" \"));\n    if (cb) c.baseVal = cv;\n    else this.className = cv;\n  }\n\n  function classedFunction() {\n    (value.apply(this, arguments)\n        ? classedAdd\n        : classedRemove).call(this);\n  }\n\n  return this.each(typeof value === \"function\"\n      ? classedFunction : value\n      ? classedAdd\n      : classedRemove);\n}\nd3_selectionPrototype.style = function(name, value, priority) {\n  if (arguments.length < 3) priority = \"\";\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) return window\n      .getComputedStyle(this.node(), null)\n      .getPropertyValue(name);\n\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return this.each(value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant));\n};\nd3_selectionPrototype.property = function(name, value) {\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) return this.node()[name];\n\n  function propertyNull() {\n    delete this[name];\n  }\n\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return this.each(value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant));\n};\nd3_selectionPrototype.text = function(value) {\n  return arguments.length < 1\n      ? this.node().textContent : this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; });\n};\nd3_selectionPrototype.html = function(value) {\n  return arguments.length < 1\n      ? this.node().innerHTML : this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; });\n};\n// TODO append(node)?\n// TODO append(function)?\nd3_selectionPrototype.append = function(name) {\n  name = d3.ns.qualify(name);\n\n  function append() {\n    return this.appendChild(document.createElementNS(this.namespaceURI, name));\n  }\n\n  function appendNS() {\n    return this.appendChild(document.createElementNS(name.space, name.local));\n  }\n\n  return this.select(name.local ? appendNS : append);\n};\n// TODO insert(node, function)?\n// TODO insert(function, string)?\n// TODO insert(function, function)?\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3.ns.qualify(name);\n\n  function insert() {\n    return this.insertBefore(\n        document.createElementNS(this.namespaceURI, name),\n        d3_select(before, this));\n  }\n\n  function insertNS() {\n    return this.insertBefore(\n        document.createElementNS(name.space, name.local),\n        d3_select(before, this));\n  }\n\n  return this.select(name.local ? insertNS : insert);\n};\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(function() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  });\n};\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        n1 = Math.max(n, m),\n        updateNodes = [],\n        enterNodes = [],\n        exitNodes = [],\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = [],\n          keyValue,\n          j = groupData.length;\n\n      for (i = -1; ++i < n;) {\n        keyValue = key.call(node = group[i], node.__data__, i);\n        if (nodeByKeyValue.has(keyValue)) {\n          exitNodes[j++] = node; // duplicate key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues.push(keyValue);\n      }\n\n      for (i = -1; ++i < m;) {\n        keyValue = key.call(groupData, nodeData = groupData[i], i)\n        if (nodeByKeyValue.has(keyValue)) {\n          updateNodes[i] = node = nodeByKeyValue.get(keyValue);\n          node.__data__ = nodeData;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n        nodeByKeyValue.remove(keyValue);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValues[i])) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        updateNodes[i] = exitNodes[i] = null;\n      }\n      for (; i < n1; ++i) {\n        exitNodes[i] = group[i];\n        enterNodes[i] = updateNodes[i] = null;\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\nd3_selectionPrototype.datum =\nd3_selectionPrototype.map = function(value) {\n  return arguments.length < 1\n      ? this.property(\"__data__\")\n      : this.property(\"__data__\", value);\n};\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3.ascending;\n  return function(a, b) {\n    return comparator(a && a.__data__, b && b.__data__);\n  };\n}\n// type can be namespaced, e.g., \"click.foo\"\n// listener can be null for removal\nd3_selectionPrototype.on = function(type, listener, capture) {\n  if (arguments.length < 3) capture = false;\n\n  // parse the type specifier\n  var name = \"__on\" + type, i = type.indexOf(\".\");\n  if (i > 0) type = type.substring(0, i);\n\n  // if called with only one argument, return the current listener\n  if (arguments.length < 2) return (i = this.node()[name]) && i._;\n\n  // remove the old event listener, and add the new event listener\n  return this.each(function(d, i) {\n    var node = this,\n        o = node[name];\n\n    // remove the old listener, if any (using the previously-set capture)\n    if (o) {\n      node.removeEventListener(type, o, o.$);\n      delete node[name];\n    }\n\n    // add the new listener, if any (remembering the capture flag)\n    if (listener) {\n      node.addEventListener(type, node[name] = l, l.$ = capture);\n      l._ = listener; // stash the unwrapped listener for get\n    }\n\n    // wrapped event listener that preserves i\n    function l(e) {\n      var o = d3.event; // Events can be reentrant (e.g., focus).\n      d3.event = e;\n      try {\n        listener.call(node, node.__data__, i);\n      } finally {\n        d3.event = o;\n      }\n    }\n  });\n};\nd3_selectionPrototype.each = function(callback) {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      var node = group[i];\n      if (node) callback.call(node, node.__data__, i, j);\n    }\n  }\n  return this;\n};\n//\n// Note: assigning to the arguments array simultaneously changes the value of\n// the corresponding argument!\n//\n// TODO The `this` argument probably shouldn't be the first argument to the\n// callback, anyway, since it's redundant. However, that will require a major\n// version bump due to backwards compatibility, so I'm not changing it right\n// away.\n//\nd3_selectionPrototype.call = function(callback) {\n  callback.apply(this, (arguments[0] = this, arguments));\n  return this;\n};\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\nd3_selectionPrototype.node = function(callback) {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\nd3_selectionPrototype.transition = function() {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      subgroup.push((node = group[i]) ? {node: node, delay: d3_transitionDelay, duration: d3_transitionDuration} : null);\n    }\n  }\n\n  return d3_transition(subgroups, d3_transitionId || ++d3_transitionNextId, Date.now());\n};\nvar d3_selectionRoot = d3_selection([[document]]);\n\nd3_selectionRoot[0].parentNode = d3_selectRoot;\n\n// TODO fast singleton implementation!\n// TODO select(function)\nd3.select = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.select(selector)\n      : d3_selection([[selector]]); // assume node\n};\n\n// TODO selectAll(function)\nd3.selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.selectAll(selector)\n      : d3_selection([d3_array(selector)]); // assume node[]\n};\nfunction d3_selection_enter(selection) {\n  d3_arraySubclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3.selection.enter = d3_selection_enter;\nd3.selection.enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\nfunction d3_transition(groups, id, time) {\n  d3_arraySubclass(groups, d3_transitionPrototype);\n\n  var tweens = new d3_Map,\n      event = d3.dispatch(\"start\", \"end\"),\n      ease = d3_transitionEase;\n\n  groups.id = id;\n\n  groups.time = time;\n\n  groups.tween = function(name, tween) {\n    if (arguments.length < 2) return tweens.get(name);\n    if (tween == null) tweens.remove(name);\n    else tweens.set(name, tween);\n    return groups;\n  };\n\n  groups.ease = function(value) {\n    if (!arguments.length) return ease;\n    ease = typeof value === \"function\" ? value : d3.ease.apply(d3, arguments);\n    return groups;\n  };\n\n  groups.each = function(type, listener) {\n    if (arguments.length < 2) return d3_transition_each.call(groups, type);\n    event.on(type, listener);\n    return groups;\n  };\n\n  d3.timer(function(elapsed) {\n    groups.each(function(d, i, j) {\n      var tweened = [],\n          node = this,\n          delay = groups[j][i].delay,\n          duration = groups[j][i].duration,\n          lock = node.__transition__ || (node.__transition__ = {active: 0, count: 0});\n\n      ++lock.count;\n\n      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);\n\n      function start(elapsed) {\n        if (lock.active > id) return stop();\n        lock.active = id;\n\n        tweens.forEach(function(key, value) {\n          if (tween = value.call(node, d, i)) {\n            tweened.push(tween);\n          }\n        });\n\n        event.start.call(node, d, i);\n        if (!tick(elapsed)) d3.timer(tick, 0, time);\n        return 1;\n      }\n\n      function tick(elapsed) {\n        if (lock.active !== id) return stop();\n\n        var t = (elapsed - delay) / duration,\n            e = ease(t),\n            n = tweened.length;\n\n        while (n > 0) {\n          tweened[--n].call(node, e);\n        }\n\n        if (t >= 1) {\n          stop();\n          d3_transitionId = id;\n          event.end.call(node, d, i);\n          d3_transitionId = 0;\n          return 1;\n        }\n      }\n\n      function stop() {\n        if (!--lock.count) delete node.__transition__;\n        return 1;\n      }\n    });\n    return 1;\n  }, 0, time);\n\n  return groups;\n}\n\nvar d3_transitionRemove = {};\n\nfunction d3_transitionNull(d, i, a) {\n  return a != \"\" && d3_transitionRemove;\n}\n\nfunction d3_transitionTween(name, b) {\n  var interpolate = d3_interpolateByName(name);\n\n  function transitionFunction(d, i, a) {\n    var v = b.call(this, d, i);\n    return v == null\n        ? a != \"\" && d3_transitionRemove\n        : a != v && interpolate(a, v);\n  }\n\n  function transitionString(d, i, a) {\n    return a != b && interpolate(a, b);\n  }\n\n  return typeof b === \"function\" ? transitionFunction\n      : b == null ? d3_transitionNull\n      : (b += \"\", transitionString);\n}\n\nvar d3_transitionPrototype = [],\n    d3_transitionNextId = 0,\n    d3_transitionId = 0,\n    d3_transitionDefaultDelay = 0,\n    d3_transitionDefaultDuration = 250,\n    d3_transitionDefaultEase = d3.ease(\"cubic-in-out\"),\n    d3_transitionDelay = d3_transitionDefaultDelay,\n    d3_transitionDuration = d3_transitionDefaultDuration,\n    d3_transitionEase = d3_transitionDefaultEase;\n\nd3_transitionPrototype.call = d3_selectionPrototype.call;\n\nd3.transition = function(selection) {\n  return arguments.length\n      ? (d3_transitionId ? selection.transition() : selection)\n      : d3_selectionRoot.transition();\n};\n\nd3.transition.prototype = d3_transitionPrototype;\nd3_transitionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {\n        if (\"__data__\" in node.node) subnode.__data__ = node.node.__data__;\n        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n};\nd3_transitionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnodes,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subnodes = selector.call(node.node, node.node.__data__, i);\n        subgroups.push(subgroup = []);\n        for (var k = -1, o = subnodes.length; ++k < o;) {\n          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});\n        }\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n};\nd3_transitionPrototype.attr = function(name, value) {\n  return this.attrTween(name, d3_transitionTween(name, value));\n};\n\nd3_transitionPrototype.attrTween = function(nameNS, tween) {\n  var name = d3.ns.qualify(nameNS);\n\n  function attrTween(d, i) {\n    var f = tween.call(this, d, i, this.getAttribute(name));\n    return f === d3_transitionRemove\n        ? (this.removeAttribute(name), null)\n        : f && function(t) { this.setAttribute(name, f(t)); };\n  }\n\n  function attrTweenNS(d, i) {\n    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n    return f === d3_transitionRemove\n        ? (this.removeAttributeNS(name.space, name.local), null)\n        : f && function(t) { this.setAttributeNS(name.space, name.local, f(t)); };\n  }\n\n  return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n};\nd3_transitionPrototype.style = function(name, value, priority) {\n  if (arguments.length < 3) priority = \"\";\n  return this.styleTween(name, d3_transitionTween(name, value), priority);\n};\n\nd3_transitionPrototype.styleTween = function(name, tween, priority) {\n  if (arguments.length < 3) priority = \"\";\n  return this.tween(\"style.\" + name, function(d, i) {\n    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));\n    return f === d3_transitionRemove\n        ? (this.style.removeProperty(name), null)\n        : f && function(t) { this.style.setProperty(name, f(t), priority); };\n  });\n};\nd3_transitionPrototype.text = function(value) {\n  return this.tween(\"text\", function(d, i) {\n    this.textContent = typeof value === \"function\"\n        ? value.call(this, d, i)\n        : value;\n  });\n};\nd3_transitionPrototype.remove = function() {\n  return this.each(\"end.transition\", function() {\n    var p;\n    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\n  });\n};\nd3_transitionPrototype.delay = function(value) {\n  var groups = this;\n  return groups.each(typeof value === \"function\"\n      ? function(d, i, j) { groups[j][i].delay = value.apply(this, arguments) | 0; }\n      : (value = value | 0, function(d, i, j) { groups[j][i].delay = value; }));\n};\nd3_transitionPrototype.duration = function(value) {\n  var groups = this;\n  return groups.each(typeof value === \"function\"\n      ? function(d, i, j) { groups[j][i].duration = Math.max(1, value.apply(this, arguments) | 0); }\n      : (value = Math.max(1, value | 0), function(d, i, j) { groups[j][i].duration = value; }));\n};\nfunction d3_transition_each(callback) {\n  var id = d3_transitionId,\n      ease = d3_transitionEase,\n      delay = d3_transitionDelay,\n      duration = d3_transitionDuration;\n\n  d3_transitionId = this.id;\n  d3_transitionEase = this.ease();\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) {\n        d3_transitionDelay = this[j][i].delay;\n        d3_transitionDuration = this[j][i].duration;\n        callback.call(node = node.node, node.__data__, i, j);\n      }\n    }\n  }\n\n  d3_transitionId = id;\n  d3_transitionEase = ease;\n  d3_transitionDelay = delay;\n  d3_transitionDuration = duration;\n  return this;\n}\nd3_transitionPrototype.transition = function() {\n  return this.select(d3_this);\n};\nvar d3_timer_queue = null,\n    d3_timer_interval, // is an interval (or frame) active?\n    d3_timer_timeout; // is a timeout active?\n\n// The timer will continue to fire until callback returns true.\nd3.timer = function(callback, delay, then) {\n  var found = false,\n      t0,\n      t1 = d3_timer_queue;\n\n  if (arguments.length < 3) {\n    if (arguments.length < 2) delay = 0;\n    else if (!isFinite(delay)) return;\n    then = Date.now();\n  }\n\n  // See if the callback's already in the queue.\n  while (t1) {\n    if (t1.callback === callback) {\n      t1.then = then;\n      t1.delay = delay;\n      found = true;\n      break;\n    }\n    t0 = t1;\n    t1 = t1.next;\n  }\n\n  // Otherwise, add the callback to the queue.\n  if (!found) d3_timer_queue = {\n    callback: callback,\n    then: then,\n    delay: delay,\n    next: d3_timer_queue\n  };\n\n  // Start animatin'!\n  if (!d3_timer_interval) {\n    d3_timer_timeout = clearTimeout(d3_timer_timeout);\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nfunction d3_timer_step() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  var delay = d3_timer_flush() - now;\n  if (delay > 24) {\n    if (isFinite(delay)) {\n      clearTimeout(d3_timer_timeout);\n      d3_timer_timeout = setTimeout(d3_timer_step, delay);\n    }\n    d3_timer_interval = 0;\n  } else {\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nd3.timer.flush = function() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (!t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  d3_timer_flush();\n};\n\n// Flush after callbacks, to avoid concurrent queue modification.\nfunction d3_timer_flush() {\n  var t0 = null,\n      t1 = d3_timer_queue,\n      then = Infinity;\n  while (t1) {\n    if (t1.flush) {\n      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\n    } else {\n      then = Math.min(then, t1.then + t1.delay);\n      t1 = (t0 = t1).next;\n    }\n  }\n  return then;\n}\n\nvar d3_timer_frame = window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.oRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || function(callback) { setTimeout(callback, 17); };\nd3.transform = function(string) {\n  var g = document.createElementNS(d3.ns.prefix.svg, \"g\"),\n      identity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};\n  return (d3.transform = function(string) {\n    g.setAttribute(\"transform\", string);\n    var t = g.transform.baseVal.consolidate();\n    return new d3_transform(t ? t.matrix : identity);\n  })(string);\n};\n\n// Compute x-scale and normalize the first row.\n// Compute shear and make second row orthogonal to first.\n// Compute y-scale and normalize the second row.\n// Finally, compute the rotation.\nfunction d3_transform(m) {\n  var r0 = [m.a, m.b],\n      r1 = [m.c, m.d],\n      kx = d3_transformNormalize(r0),\n      kz = d3_transformDot(r0, r1),\n      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n  if (r0[0] * r1[1] < r1[0] * r0[1]) {\n    r0[0] *= -1;\n    r0[1] *= -1;\n    kx *= -1;\n    kz *= -1;\n  }\n  this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;\n  this.translate = [m.e, m.f];\n  this.scale = [kx, ky];\n  this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;\n};\n\nd3_transform.prototype.toString = function() {\n  return \"translate(\" + this.translate\n      + \")rotate(\" + this.rotate\n      + \")skewX(\" + this.skew\n      + \")scale(\" + this.scale\n      + \")\";\n};\n\nfunction d3_transformDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\nfunction d3_transformNormalize(a) {\n  var k = Math.sqrt(d3_transformDot(a, a));\n  if (k) {\n    a[0] /= k;\n    a[1] /= k;\n  }\n  return k;\n}\n\nfunction d3_transformCombine(a, b, k) {\n  a[0] += k * b[0];\n  a[1] += k * b[1];\n  return a;\n}\n\nvar d3_transformDegrees = 180 / Math.PI;\nd3.mouse = function(container) {\n  return d3_mousePoint(container, d3_eventSource());\n};\n\n// https://bugs.webkit.org/show_bug.cgi?id=44083\nvar d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n\nfunction d3_mousePoint(container, e) {\n  var svg = container.ownerSVGElement || container;\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {\n      svg = d3.select(document.body)\n        .append(\"svg\")\n          .style(\"position\", \"absolute\")\n          .style(\"top\", 0)\n          .style(\"left\", 0);\n      var ctm = svg[0][0].getScreenCTM();\n      d3_mouse_bug44083 = !(ctm.f || ctm.e);\n      svg.remove();\n    }\n    if (d3_mouse_bug44083) {\n      point.x = e.pageX;\n      point.y = e.pageY;\n    } else {\n      point.x = e.clientX;\n      point.y = e.clientY;\n    }\n    point = point.matrixTransform(container.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n  var rect = container.getBoundingClientRect();\n  return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];\n};\nd3.touches = function(container, touches) {\n  if (arguments.length < 2) touches = d3_eventSource().touches;\n  return touches ? d3_array(touches).map(function(touch) {\n    var point = d3_mousePoint(container, touch);\n    point.identifier = touch.identifier;\n    return point;\n  }) : [];\n};\nfunction d3_noop() {}\nd3.scale = {};\n\nfunction d3_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction d3_scaleRange(scale) {\n  return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n}\nfunction d3_scale_nice(domain, nice) {\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      dx;\n\n  if (x1 < x0) {\n    dx = i0; i0 = i1; i1 = dx;\n    dx = x0; x0 = x1; x1 = dx;\n  }\n\n  if (dx = x1 - x0) {\n    nice = nice(dx);\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n  }\n\n  return domain;\n}\n\nfunction d3_scale_niceDefault() {\n  return Math;\n}\nd3.scale.linear = function() {\n  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);\n};\n\nfunction d3_scale_linear(domain, range, interpolate, clamp) {\n  var output,\n      input;\n\n  function rescale() {\n    var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,\n        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n    output = linear(domain, range, uninterpolate, interpolate);\n    input = linear(range, domain, uninterpolate, d3.interpolate);\n    return scale;\n  }\n\n  function scale(x) {\n    return output(x);\n  }\n\n  // Note: requires range is coercible to number!\n  scale.invert = function(y) {\n    return input(y);\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(Number);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.rangeRound = function(x) {\n    return scale.range(x).interpolate(d3.interpolateRound);\n  };\n\n  scale.clamp = function(x) {\n    if (!arguments.length) return clamp;\n    clamp = x;\n    return rescale();\n  };\n\n  scale.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolate = x;\n    return rescale();\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  scale.nice = function() {\n    d3_scale_nice(domain, d3_scale_linearNice);\n    return rescale();\n  };\n\n  scale.copy = function() {\n    return d3_scale_linear(domain, range, interpolate, clamp);\n  };\n\n  return rescale();\n}\n\nfunction d3_scale_linearRebind(scale, linear) {\n  return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n}\n\nfunction d3_scale_linearNice(dx) {\n  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n  return {\n    floor: function(x) { return Math.floor(x / dx) * dx; },\n    ceil: function(x) { return Math.ceil(x / dx) * dx; }\n  };\n}\n\nfunction d3_scale_linearTickRange(domain, m) {\n  var extent = d3_scaleExtent(domain),\n      span = extent[1] - extent[0],\n      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n      err = m / span * step;\n\n  // Filter ticks to get closer to the desired count.\n  if (err <= .15) step *= 10;\n  else if (err <= .35) step *= 5;\n  else if (err <= .75) step *= 2;\n\n  // Round start and stop values to step interval.\n  extent[0] = Math.ceil(extent[0] / step) * step;\n  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive\n  extent[2] = step;\n  return extent;\n}\n\nfunction d3_scale_linearTicks(domain, m) {\n  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n}\n\nfunction d3_scale_linearTickFormat(domain, m) {\n  return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\n}\nfunction d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n  var u = uninterpolate(domain[0], domain[1]),\n      i = interpolate(range[0], range[1]);\n  return function(x) {\n    return i(u(x));\n  };\n}\nfunction d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n  var u = [],\n      i = [],\n      j = 0,\n      k = Math.min(domain.length, range.length) - 1;\n\n  // Handle descending domains.\n  if (domain[k] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++j <= k) {\n    u.push(uninterpolate(domain[j - 1], domain[j]));\n    i.push(interpolate(range[j - 1], range[j]));\n  }\n\n  return function(x) {\n    var j = d3.bisect(domain, x, 1, k) - 1;\n    return i[j](u[j](x));\n  };\n}\nd3.scale.log = function() {\n  return d3_scale_log(d3.scale.linear(), d3_scale_logp);\n};\n\nfunction d3_scale_log(linear, log) {\n  var pow = log.pow;\n\n  function scale(x) {\n    return linear(log(x));\n  }\n\n  scale.invert = function(x) {\n    return pow(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(pow);\n    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\n    pow = log.pow;\n    linear.domain(x.map(log));\n    return scale;\n  };\n\n  scale.nice = function() {\n    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n    return scale;\n  };\n\n  scale.ticks = function() {\n    var extent = d3_scaleExtent(linear.domain()),\n        ticks = [];\n    if (extent.every(isFinite)) {\n      var i = Math.floor(extent[0]),\n          j = Math.ceil(extent[1]),\n          u = pow(extent[0]),\n          v = pow(extent[1]);\n      if (log === d3_scale_logn) {\n        ticks.push(pow(i));\n        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n      } else {\n        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n        ticks.push(pow(i));\n      }\n      for (i = 0; ticks[i] < u; i++) {} // strip small values\n      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values\n      ticks = ticks.slice(i, j);\n    }\n    return ticks;\n  };\n\n  scale.tickFormat = function(n, format) {\n    if (arguments.length < 2) format = d3_scale_logFormat;\n    if (arguments.length < 1) return format;\n    var k = n / scale.ticks().length,\n        f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),\n        e;\n    return function(d) {\n      return d / pow(f(log(d) + e)) < k ? format(d) : \"\";\n    };\n  };\n\n  scale.copy = function() {\n    return d3_scale_log(linear.copy(), log);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n}\n\nvar d3_scale_logFormat = d3.format(\".0e\");\n\nfunction d3_scale_logp(x) {\n  return Math.log(x < 0 ? 0 : x) / Math.LN10;\n}\n\nfunction d3_scale_logn(x) {\n  return -Math.log(x > 0 ? 0 : -x) / Math.LN10;\n}\n\nd3_scale_logp.pow = function(x) {\n  return Math.pow(10, x);\n};\n\nd3_scale_logn.pow = function(x) {\n  return -Math.pow(10, -x);\n};\nd3.scale.pow = function() {\n  return d3_scale_pow(d3.scale.linear(), 1);\n};\n\nfunction d3_scale_pow(linear, exponent) {\n  var powp = d3_scale_powPow(exponent),\n      powb = d3_scale_powPow(1 / exponent);\n\n  function scale(x) {\n    return linear(powp(x));\n  }\n\n  scale.invert = function(x) {\n    return powb(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(powb);\n    linear.domain(x.map(powp));\n    return scale;\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(scale.domain(), m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(scale.domain(), m);\n  };\n\n  scale.nice = function() {\n    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n  };\n\n  scale.exponent = function(x) {\n    if (!arguments.length) return exponent;\n    var domain = scale.domain();\n    powp = d3_scale_powPow(exponent = x);\n    powb = d3_scale_powPow(1 / exponent);\n    return scale.domain(domain);\n  };\n\n  scale.copy = function() {\n    return d3_scale_pow(linear.copy(), exponent);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n}\n\nfunction d3_scale_powPow(e) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n  };\n}\nd3.scale.sqrt = function() {\n  return d3.scale.pow().exponent(.5);\n};\nd3.scale.ordinal = function() {\n  return d3_scale_ordinal([], {t: \"range\", x: []});\n};\n\nfunction d3_scale_ordinal(domain, ranger) {\n  var index,\n      range,\n      rangeBand;\n\n  function scale(x) {\n    return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];\n  }\n\n  function steps(start, step) {\n    return d3.range(domain.length).map(function(i) { return start + step * i; });\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = [];\n    index = new d3_Map;\n    var i = -1, n = x.length, xi;\n    while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n    return scale[ranger.t](ranger.x, ranger.p);\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    rangeBand = 0;\n    ranger = {t: \"range\", x: x};\n    return scale;\n  };\n\n  scale.rangePoints = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (domain.length - 1 + padding);\n    range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);\n    rangeBand = 0;\n    ranger = {t: \"rangePoints\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var reverse = x[1] < x[0],\n        start = x[reverse - 0],\n        stop = x[1 - reverse],\n        step = (stop - start) / (domain.length + padding);\n    range = steps(start + step * padding, step);\n    if (reverse) range.reverse();\n    rangeBand = step * (1 - padding);\n    ranger = {t: \"rangeBands\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeRoundBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var reverse = x[1] < x[0],\n        start = x[reverse - 0],\n        stop = x[1 - reverse],\n        step = Math.floor((stop - start) / (domain.length + padding)),\n        error = stop - start - (domain.length - padding) * step;\n    range = steps(start + Math.round(error / 2), step);\n    if (reverse) range.reverse();\n    rangeBand = Math.round(step * (1 - padding));\n    ranger = {t: \"rangeRoundBands\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeBand = function() {\n    return rangeBand;\n  };\n\n  scale.rangeExtent = function() {\n    return d3_scaleExtent(ranger.x);\n  };\n\n  scale.copy = function() {\n    return d3_scale_ordinal(domain, ranger);\n  };\n\n  return scale.domain(domain);\n}\n/*\n * This product includes color specifications and designs developed by Cynthia\n * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.\n */\n\nd3.scale.category10 = function() {\n  return d3.scale.ordinal().range(d3_category10);\n};\n\nd3.scale.category20 = function() {\n  return d3.scale.ordinal().range(d3_category20);\n};\n\nd3.scale.category20b = function() {\n  return d3.scale.ordinal().range(d3_category20b);\n};\n\nd3.scale.category20c = function() {\n  return d3.scale.ordinal().range(d3_category20c);\n};\n\nvar d3_category10 = [\n  \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n  \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"\n];\n\nvar d3_category20 = [\n  \"#1f77b4\", \"#aec7e8\",\n  \"#ff7f0e\", \"#ffbb78\",\n  \"#2ca02c\", \"#98df8a\",\n  \"#d62728\", \"#ff9896\",\n  \"#9467bd\", \"#c5b0d5\",\n  \"#8c564b\", \"#c49c94\",\n  \"#e377c2\", \"#f7b6d2\",\n  \"#7f7f7f\", \"#c7c7c7\",\n  \"#bcbd22\", \"#dbdb8d\",\n  \"#17becf\", \"#9edae5\"\n];\n\nvar d3_category20b = [\n  \"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\",\n  \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\",\n  \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\",\n  \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\",\n  \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\"\n];\n\nvar d3_category20c = [\n  \"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\",\n  \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\",\n  \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\",\n  \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\",\n  \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\"\n];\nd3.scale.quantile = function() {\n  return d3_scale_quantile([], []);\n};\n\nfunction d3_scale_quantile(domain, range) {\n  var thresholds;\n\n  function rescale() {\n    var k = 0,\n        n = domain.length,\n        q = range.length;\n    thresholds = [];\n    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n    return scale;\n  }\n\n  function scale(x) {\n    if (isNaN(x = +x)) return NaN;\n    return range[d3.bisect(thresholds, x)];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.quantiles = function() {\n    return thresholds;\n  };\n\n  scale.copy = function() {\n    return d3_scale_quantile(domain, range); // copy on write!\n  };\n\n  return rescale();\n}\nd3.scale.quantize = function() {\n  return d3_scale_quantize(0, 1, [0, 1]);\n};\n\nfunction d3_scale_quantize(x0, x1, range) {\n  var kx, i;\n\n  function scale(x) {\n    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n  }\n\n  function rescale() {\n    kx = range.length / (x1 - x0);\n    i = range.length - 1;\n    return scale;\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return [x0, x1];\n    x0 = +x[0];\n    x1 = +x[x.length - 1];\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.copy = function() {\n    return d3_scale_quantize(x0, x1, range); // copy on write\n  };\n\n  return rescale();\n}\nd3.scale.identity = function() {\n  return d3_scale_identity([0, 1]);\n};\n\nfunction d3_scale_identity(domain) {\n\n  function identity(x) { return +x; }\n\n  identity.invert = identity;\n\n  identity.domain = identity.range = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(identity);\n    return identity;\n  };\n\n  identity.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  identity.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  identity.copy = function() {\n    return d3_scale_identity(domain);\n  };\n\n  return identity;\n}\nd3.svg = {};\nd3.svg.arc = function() {\n  var innerRadius = d3_svg_arcInnerRadius,\n      outerRadius = d3_svg_arcOuterRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  function arc() {\n    var r0 = innerRadius.apply(this, arguments),\n        r1 = outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),\n        df = da < Math.PI ? \"0\" : \"1\",\n        c0 = Math.cos(a0),\n        s0 = Math.sin(a0),\n        c1 = Math.cos(a1),\n        s1 = Math.sin(a1);\n    return da >= d3_svg_arcMax\n      ? (r0\n      ? \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"M0,\" + r0\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + (-r0)\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0\n      + \"Z\"\n      : \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"Z\")\n      : (r0\n      ? \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L\" + r0 * c1 + \",\" + r0 * s1\n      + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0\n      + \"Z\"\n      : \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L0,0\"\n      + \"Z\");\n  }\n\n  arc.innerRadius = function(v) {\n    if (!arguments.length) return innerRadius;\n    innerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.outerRadius = function(v) {\n    if (!arguments.length) return outerRadius;\n    outerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.centroid = function() {\n    var r = (innerRadius.apply(this, arguments)\n        + outerRadius.apply(this, arguments)) / 2,\n        a = (startAngle.apply(this, arguments)\n        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\n    return [Math.cos(a) * r, Math.sin(a) * r];\n  };\n\n  return arc;\n};\n\nvar d3_svg_arcOffset = -Math.PI / 2,\n    d3_svg_arcMax = 2 * Math.PI - 1e-6;\n\nfunction d3_svg_arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction d3_svg_arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction d3_svg_arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction d3_svg_line(projection) {\n  var x = d3_svg_lineX,\n      y = d3_svg_lineY,\n      interpolate = d3_svg_lineInterpolatorDefault,\n      interpolator = d3_svg_lineInterpolators.get(interpolate),\n      tension = .7;\n\n  function line(d) {\n    return d.length < 1 ? null : \"M\" + interpolator(projection(d3_svg_linePoints(this, d, x, y)), tension);\n  }\n\n  line.x = function(v) {\n    if (!arguments.length) return x;\n    x = v;\n    return line;\n  };\n\n  line.y = function(v) {\n    if (!arguments.length) return y;\n    y = v;\n    return line;\n  };\n\n  line.interpolate = function(v) {\n    if (!arguments.length) return interpolate;\n    if (!d3_svg_lineInterpolators.has(v += \"\")) v = d3_svg_lineInterpolatorDefault;\n    interpolator = d3_svg_lineInterpolators.get(interpolate = v);\n    return line;\n  };\n\n  line.tension = function(v) {\n    if (!arguments.length) return tension;\n    tension = v;\n    return line;\n  };\n\n  return line;\n}\n\nd3.svg.line = function() {\n  return d3_svg_line(Object);\n};\n\n// Converts the specified array of data into an array of points\n// (x-y tuples), by evaluating the specified `x` and `y` functions on each\n// data point. The `this` context of the evaluated functions is the specified\n// \"self\" object; each function is passed the current datum and index.\nfunction d3_svg_linePoints(self, d, x, y) {\n  var points = [],\n      i = -1,\n      n = d.length,\n      fx = typeof x === \"function\",\n      fy = typeof y === \"function\",\n      value;\n  if (fx && fy) {\n    while (++i < n) points.push([\n      x.call(self, value = d[i], i),\n      y.call(self, value, i)\n    ]);\n  } else if (fx) {\n    while (++i < n) points.push([x.call(self, d[i], i), y]);\n  } else if (fy) {\n    while (++i < n) points.push([x, y.call(self, d[i], i)]);\n  } else {\n    while (++i < n) points.push([x, y]);\n  }\n  return points;\n}\n\n// The default `x` property, which references d[0].\nfunction d3_svg_lineX(d) {\n  return d[0];\n}\n\n// The default `y` property, which references d[1].\nfunction d3_svg_lineY(d) {\n  return d[1];\n}\n\nvar d3_svg_lineInterpolatorDefault = \"linear\";\n\n// The various interpolators supported by the `line` class.\nvar d3_svg_lineInterpolators = d3.map({\n  \"linear\": d3_svg_lineLinear,\n  \"step-before\": d3_svg_lineStepBefore,\n  \"step-after\": d3_svg_lineStepAfter,\n  \"basis\": d3_svg_lineBasis,\n  \"basis-open\": d3_svg_lineBasisOpen,\n  \"basis-closed\": d3_svg_lineBasisClosed,\n  \"bundle\": d3_svg_lineBundle,\n  \"cardinal\": d3_svg_lineCardinal,\n  \"cardinal-open\": d3_svg_lineCardinalOpen,\n  \"cardinal-closed\": d3_svg_lineCardinalClosed,\n  \"monotone\": d3_svg_lineMonotone\n});\n\n// Linear interpolation; generates \"L\" commands.\nfunction d3_svg_lineLinear(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"L\", (p = points[i])[0], \",\", p[1]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepBefore(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepAfter(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n  return path.join(\"\");\n}\n\n// Open cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalOpen(points, tension) {\n  return points.length < 4\n      ? d3_svg_lineLinear(points)\n      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Closed cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalClosed(points, tension) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),\n        d3_svg_lineCardinalTangents([points[points.length - 2]]\n        .concat(points, [points[1]]), tension));\n}\n\n// Cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinal(points, tension, closed) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite(points,\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Hermite spline construction; generates \"C\" commands.\nfunction d3_svg_lineHermite(points, tangents) {\n  if (tangents.length < 1\n      || (points.length != tangents.length\n      && points.length != tangents.length + 2)) {\n    return d3_svg_lineLinear(points);\n  }\n\n  var quad = points.length != tangents.length,\n      path = \"\",\n      p0 = points[0],\n      p = points[1],\n      t0 = tangents[0],\n      t = t0,\n      pi = 1;\n\n  if (quad) {\n    path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3)\n        + \",\" + p[0] + \",\" + p[1];\n    p0 = points[1];\n    pi = 2;\n  }\n\n  if (tangents.length > 1) {\n    t = tangents[1];\n    p = points[pi];\n    pi++;\n    path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1])\n        + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n        + \",\" + p[0] + \",\" + p[1];\n    for (var i = 2; i < tangents.length; i++, pi++) {\n      p = points[pi];\n      t = tangents[i];\n      path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n          + \",\" + p[0] + \",\" + p[1];\n    }\n  }\n\n  if (quad) {\n    var lp = points[pi];\n    path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3)\n        + \",\" + lp[0] + \",\" + lp[1];\n  }\n\n  return path;\n}\n\n// Generates tangents for a cardinal spline.\nfunction d3_svg_lineCardinalTangents(points, tension) {\n  var tangents = [],\n      a = (1 - tension) / 2,\n      p0,\n      p1 = points[0],\n      p2 = points[1],\n      i = 1,\n      n = points.length;\n  while (++i < n) {\n    p0 = p1;\n    p1 = p2;\n    p2 = points[i];\n    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n  }\n  return tangents;\n}\n\n// B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasis(points) {\n  if (points.length < 3) return d3_svg_lineLinear(points);\n  var i = 1,\n      n = points.length,\n      pi = points[0],\n      x0 = pi[0],\n      y0 = pi[1],\n      px = [x0, x0, x0, (pi = points[1])[0]],\n      py = [y0, y0, y0, pi[1]],\n      path = [x0, \",\", y0];\n  d3_svg_lineBasisBezier(path, px, py);\n  while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  i = -1;\n  while (++i < 2) {\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Open B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisOpen(points) {\n  if (points.length < 4) return d3_svg_lineLinear(points);\n  var path = [],\n      i = -1,\n      n = points.length,\n      pi,\n      px = [0],\n      py = [0];\n  while (++i < 3) {\n    pi = points[i];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)\n    + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n  --i; while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Closed B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisClosed(points) {\n  var path,\n      i = -1,\n      n = points.length,\n      m = n + 4,\n      pi,\n      px = [],\n      py = [];\n  while (++i < 4) {\n    pi = points[i % n];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path = [\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\",\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)\n  ];\n  --i; while (++i < m) {\n    pi = points[i % n];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\nfunction d3_svg_lineBundle(points, tension) {\n  var n = points.length - 1,\n      x0 = points[0][0],\n      y0 = points[0][1],\n      dx = points[n][0] - x0,\n      dy = points[n][1] - y0,\n      i = -1,\n      p,\n      t;\n  while (++i <= n) {\n    p = points[i];\n    t = i / n;\n    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n  }\n  return d3_svg_lineBasis(points);\n}\n\n// Returns the dot product of the given four-element vectors.\nfunction d3_svg_lineDot4(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n// Matrix to transform basis (b-spline) control points to bezier\n// control points. Derived from FvD 11.2.8.\nvar d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],\n    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],\n    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];\n\n// Pushes a \"C\" Bzier curve onto the specified path array, given the\n// two specified four-element arrays which define the control points.\nfunction d3_svg_lineBasisBezier(path, x, y) {\n  path.push(\n      \"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n}\n\n// Computes the slope from points p0 to p1.\nfunction d3_svg_lineSlope(p0, p1) {\n  return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n}\n\n// Compute three-point differences for the given points.\n// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference\nfunction d3_svg_lineFiniteDifferences(points) {\n  var i = 0,\n      j = points.length - 1,\n      m = [],\n      p0 = points[0],\n      p1 = points[1],\n      d = m[0] = d3_svg_lineSlope(p0, p1);\n  while (++i < j) {\n    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));\n  }\n  m[i] = d;\n  return m;\n}\n\n// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite\n// interpolation. Returns an array of tangent vectors. For details, see\n// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation\nfunction d3_svg_lineMonotoneTangents(points) {\n  var tangents = [],\n      d,\n      a,\n      b,\n      s,\n      m = d3_svg_lineFiniteDifferences(points),\n      i = -1,\n      j = points.length - 1;\n\n  // The first two steps are done by computing finite-differences:\n  // 1. Compute the slopes of the secant lines between successive points.\n  // 2. Initialize the tangents at every point as the average of the secants.\n\n  // Then, for each segment\n  while (++i < j) {\n    d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set\n    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to\n    // preserve monotonicity. Ignore step 4 and 5 for those k.\n\n    if (Math.abs(d) < 1e-6) {\n      m[i] = m[i + 1] = 0;\n    } else {\n      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.\n      a = m[i] / d;\n      b = m[i + 1] / d;\n\n      // 5. Prevent overshoot and ensure monotonicity by restricting the\n      // magnitude of vector <ak, bk> to a circle of radius 3.\n      s = a * a + b * b;\n      if (s > 9) {\n        s = d * 3 / Math.sqrt(s);\n        m[i] = s * a;\n        m[i + 1] = s * b;\n      }\n    }\n  }\n\n  // Compute the normalized tangent vector from the slopes. Note that if x is\n  // not monotonic, it's possible that the slope will be infinite, so we protect\n  // against NaN by setting the coordinate to zero.\n  i = -1; while (++i <= j) {\n    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0])\n      / (6 * (1 + m[i] * m[i]));\n    tangents.push([s || 0, m[i] * s || 0]);\n  }\n\n  return tangents;\n}\n\nfunction d3_svg_lineMonotone(points) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] +\n        d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n}\nd3.svg.line.radial = function() {\n  var line = d3_svg_line(d3_svg_lineRadial);\n  line.radius = line.x, delete line.x;\n  line.angle = line.y, delete line.y;\n  return line;\n};\n\nfunction d3_svg_lineRadial(points) {\n  var point,\n      i = -1,\n      n = points.length,\n      r,\n      a;\n  while (++i < n) {\n    point = points[i];\n    r = point[0];\n    a = point[1] + d3_svg_arcOffset;\n    point[0] = r * Math.cos(a);\n    point[1] = r * Math.sin(a);\n  }\n  return points;\n}\nfunction d3_svg_area(projection) {\n  var x0 = d3_svg_lineX,\n      x1 = d3_svg_lineX,\n      y0 = 0,\n      y1 = d3_svg_lineY,\n      interpolate,\n      i0,\n      i1,\n      tension = .7;\n\n  function area(d) {\n    if (d.length < 1) return null;\n    var points0 = d3_svg_linePoints(this, d, x0, y0),\n        points1 = d3_svg_linePoints(this, d, x0 === x1 ? d3_svg_areaX(points0) : x1, y0 === y1 ? d3_svg_areaY(points0) : y1);\n    return \"M\" + i0(projection(points1), tension)\n         + \"L\" + i1(projection(points0.reverse()), tension)\n         + \"Z\";\n  }\n\n  area.x = function(x) {\n    if (!arguments.length) return x1;\n    x0 = x1 = x;\n    return area;\n  };\n\n  area.x0 = function(x) {\n    if (!arguments.length) return x0;\n    x0 = x;\n    return area;\n  };\n\n  area.x1 = function(x) {\n    if (!arguments.length) return x1;\n    x1 = x;\n    return area;\n  };\n\n  area.y = function(y) {\n    if (!arguments.length) return y1;\n    y0 = y1 = y;\n    return area;\n  };\n\n  area.y0 = function(y) {\n    if (!arguments.length) return y0;\n    y0 = y;\n    return area;\n  };\n\n  area.y1 = function(y) {\n    if (!arguments.length) return y1;\n    y1 = y;\n    return area;\n  };\n\n  area.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    if (!d3_svg_lineInterpolators.has(x += \"\")) x = d3_svg_lineInterpolatorDefault;\n    i0 = d3_svg_lineInterpolators.get(interpolate = x);\n    i1 = i0.reverse || i0;\n    return area;\n  };\n\n  area.tension = function(x) {\n    if (!arguments.length) return tension;\n    tension = x;\n    return area;\n  };\n\n  return area.interpolate(\"linear\");\n}\n\nd3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\nd3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n\nd3.svg.area = function() {\n  return d3_svg_area(Object);\n};\n\nfunction d3_svg_areaX(points) {\n  return function(d, i) {\n    return points[i][0];\n  };\n}\n\nfunction d3_svg_areaY(points) {\n  return function(d, i) {\n    return points[i][1];\n  };\n}\nd3.svg.area.radial = function() {\n  var area = d3_svg_area(d3_svg_lineRadial);\n  area.radius = area.x, delete area.x;\n  area.innerRadius = area.x0, delete area.x0;\n  area.outerRadius = area.x1, delete area.x1;\n  area.angle = area.y, delete area.y;\n  area.startAngle = area.y0, delete area.y0;\n  area.endAngle = area.y1, delete area.y1;\n  return area;\n};\nd3.svg.chord = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      radius = d3_svg_chordRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  // TODO Allow control point to be customized.\n\n  function chord(d, i) {\n    var s = subgroup(this, source, d, i),\n        t = subgroup(this, target, d, i);\n    return \"M\" + s.p0\n      + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)\n      ? curve(s.r, s.p1, s.r, s.p0)\n      : curve(s.r, s.p1, t.r, t.p0)\n      + arc(t.r, t.p1, t.a1 - t.a0)\n      + curve(t.r, t.p1, s.r, s.p0))\n      + \"Z\";\n  }\n\n  function subgroup(self, f, d, i) {\n    var subgroup = f.call(self, d, i),\n        r = radius.call(self, subgroup, i),\n        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n    return {\n      r: r,\n      a0: a0,\n      a1: a1,\n      p0: [r * Math.cos(a0), r * Math.sin(a0)],\n      p1: [r * Math.cos(a1), r * Math.sin(a1)]\n    };\n  }\n\n  function equals(a, b) {\n    return a.a0 == b.a0 && a.a1 == b.a1;\n  }\n\n  function arc(r, p, a) {\n    return \"A\" + r + \",\" + r + \" 0 \" + +(a > Math.PI) + \",1 \" + p;\n  }\n\n  function curve(r0, p0, r1, p1) {\n    return \"Q 0,0 \" + p1;\n  }\n\n  chord.radius = function(v) {\n    if (!arguments.length) return radius;\n    radius = d3.functor(v);\n    return chord;\n  };\n\n  chord.source = function(v) {\n    if (!arguments.length) return source;\n    source = d3.functor(v);\n    return chord;\n  };\n\n  chord.target = function(v) {\n    if (!arguments.length) return target;\n    target = d3.functor(v);\n    return chord;\n  };\n\n  chord.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return chord;\n  };\n\n  chord.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return chord;\n  };\n\n  return chord;\n};\n\nfunction d3_svg_chordSource(d) {\n  return d.source;\n}\n\nfunction d3_svg_chordTarget(d) {\n  return d.target;\n}\n\nfunction d3_svg_chordRadius(d) {\n  return d.radius;\n}\n\nfunction d3_svg_chordStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_chordEndAngle(d) {\n  return d.endAngle;\n}\nd3.svg.diagonal = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      projection = d3_svg_diagonalProjection;\n\n  function diagonal(d, i) {\n    var p0 = source.call(this, d, i),\n        p3 = target.call(this, d, i),\n        m = (p0.y + p3.y) / 2,\n        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];\n    p = p.map(projection);\n    return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n  }\n\n  diagonal.source = function(x) {\n    if (!arguments.length) return source;\n    source = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.target = function(x) {\n    if (!arguments.length) return target;\n    target = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.projection = function(x) {\n    if (!arguments.length) return projection;\n    projection = x;\n    return diagonal;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalProjection(d) {\n  return [d.x, d.y];\n}\nd3.svg.diagonal.radial = function() {\n  var diagonal = d3.svg.diagonal(),\n      projection = d3_svg_diagonalProjection,\n      projection_ = diagonal.projection;\n\n  diagonal.projection = function(x) {\n    return arguments.length\n        ? projection_(d3_svg_diagonalRadialProjection(projection = x))\n        : projection;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalRadialProjection(projection) {\n  return function() {\n    var d = projection.apply(this, arguments),\n        r = d[0],\n        a = d[1] + d3_svg_arcOffset;\n    return [r * Math.cos(a), r * Math.sin(a)];\n  };\n}\nd3.svg.mouse = d3.mouse;\nd3.svg.touches = d3.touches;\nd3.svg.symbol = function() {\n  var type = d3_svg_symbolType,\n      size = d3_svg_symbolSize;\n\n  function symbol(d, i) {\n    return (d3_svg_symbols.get(type.call(this, d, i))\n        || d3_svg_symbolCircle)\n        (size.call(this, d, i));\n  }\n\n  symbol.type = function(x) {\n    if (!arguments.length) return type;\n    type = d3.functor(x);\n    return symbol;\n  };\n\n  // size of symbol in square pixels\n  symbol.size = function(x) {\n    if (!arguments.length) return size;\n    size = d3.functor(x);\n    return symbol;\n  };\n\n  return symbol;\n};\n\nfunction d3_svg_symbolSize() {\n  return 64;\n}\n\nfunction d3_svg_symbolType() {\n  return \"circle\";\n}\n\nfunction d3_svg_symbolCircle(size) {\n  var r = Math.sqrt(size / Math.PI);\n  return \"M0,\" + r\n      + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r)\n      + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r\n      + \"Z\";\n}\n\n// TODO cross-diagonal?\nvar d3_svg_symbols = d3.map({\n  \"circle\": d3_svg_symbolCircle,\n  \"cross\": function(size) {\n    var r = Math.sqrt(size / 5) / 2;\n    return \"M\" + -3 * r + \",\" + -r\n        + \"H\" + -r\n        + \"V\" + -3 * r\n        + \"H\" + r\n        + \"V\" + -r\n        + \"H\" + 3 * r\n        + \"V\" + r\n        + \"H\" + r\n        + \"V\" + 3 * r\n        + \"H\" + -r\n        + \"V\" + r\n        + \"H\" + -3 * r\n        + \"Z\";\n  },\n  \"diamond\": function(size) {\n    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n        rx = ry * d3_svg_symbolTan30;\n    return \"M0,\" + -ry\n        + \"L\" + rx + \",0\"\n        + \" 0,\" + ry\n        + \" \" + -rx + \",0\"\n        + \"Z\";\n  },\n  \"square\": function(size) {\n    var r = Math.sqrt(size) / 2;\n    return \"M\" + -r + \",\" + -r\n        + \"L\" + r + \",\" + -r\n        + \" \" + r + \",\" + r\n        + \" \" + -r + \",\" + r\n        + \"Z\";\n  },\n  \"triangle-down\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + ry\n        + \"L\" + rx +\",\" + -ry\n        + \" \" + -rx + \",\" + -ry\n        + \"Z\";\n  },\n  \"triangle-up\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + -ry\n        + \"L\" + rx +\",\" + ry\n        + \" \" + -rx + \",\" + ry\n        + \"Z\";\n  }\n});\n\nd3.svg.symbolTypes = d3_svg_symbols.keys();\n\nvar d3_svg_symbolSqrt3 = Math.sqrt(3),\n    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);\nd3.svg.axis = function() {\n  var scale = d3.scale.linear(),\n      orient = \"bottom\",\n      tickMajorSize = 6,\n      tickMinorSize = 6,\n      tickEndSize = 6,\n      tickPadding = 3,\n      tickArguments_ = [10],\n      tickValues = null,\n      tickFormat_,\n      tickSubdivide = 0;\n\n  function axis(g) {\n    g.each(function() {\n      var g = d3.select(this);\n\n      // Ticks, or domain values for ordinal scales.\n      var ticks = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues,\n          tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_;\n\n      // Minor ticks.\n      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),\n          subtick = g.selectAll(\".minor\").data(subticks, String),\n          subtickEnter = subtick.enter().insert(\"line\", \"g\").attr(\"class\", \"tick minor\").style(\"opacity\", 1e-6),\n          subtickExit = d3.transition(subtick.exit()).style(\"opacity\", 1e-6).remove(),\n          subtickUpdate = d3.transition(subtick).style(\"opacity\", 1);\n\n      // Major ticks.\n      var tick = g.selectAll(\"g\").data(ticks, String),\n          tickEnter = tick.enter().insert(\"g\", \"path\").style(\"opacity\", 1e-6),\n          tickExit = d3.transition(tick.exit()).style(\"opacity\", 1e-6).remove(),\n          tickUpdate = d3.transition(tick).style(\"opacity\", 1),\n          tickTransform;\n\n      // Domain.\n      var range = d3_scaleRange(scale),\n          path = g.selectAll(\".domain\").data([0]),\n          pathEnter = path.enter().append(\"path\").attr(\"class\", \"domain\"),\n          pathUpdate = d3.transition(path);\n\n      // Stash a snapshot of the new scale, and retrieve the old snapshot.\n      var scale1 = scale.copy(),\n          scale0 = this.__chart__ || scale1;\n      this.__chart__ = scale1;\n\n      tickEnter.append(\"line\").attr(\"class\", \"tick\");\n      tickEnter.append(\"text\");\n      tickUpdate.select(\"text\").text(tickFormat);\n\n      switch (orient) {\n        case \"bottom\": {\n          tickTransform = d3_svg_axisX;\n          subtickEnter.attr(\"y2\", tickMinorSize);\n          subtickUpdate.attr(\"x2\", 0).attr(\"y2\", tickMinorSize);\n          tickEnter.select(\"line\").attr(\"y2\", tickMajorSize);\n          tickEnter.select(\"text\").attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n          tickUpdate.select(\"line\").attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"x\", 0).attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding).attr(\"dy\", \".71em\").attr(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + tickEndSize + \"V0H\" + range[1] + \"V\" + tickEndSize);\n          break;\n        }\n        case \"top\": {\n          tickTransform = d3_svg_axisX;\n          subtickEnter.attr(\"y2\", -tickMinorSize);\n          subtickUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMinorSize);\n          tickEnter.select(\"line\").attr(\"y2\", -tickMajorSize);\n          tickEnter.select(\"text\").attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n          tickUpdate.select(\"line\").attr(\"x2\", 0).attr(\"y2\", -tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"x\", 0).attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding)).attr(\"dy\", \"0em\").attr(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + -tickEndSize + \"V0H\" + range[1] + \"V\" + -tickEndSize);\n          break;\n        }\n        case \"left\": {\n          tickTransform = d3_svg_axisY;\n          subtickEnter.attr(\"x2\", -tickMinorSize);\n          subtickUpdate.attr(\"x2\", -tickMinorSize).attr(\"y2\", 0);\n          tickEnter.select(\"line\").attr(\"x2\", -tickMajorSize);\n          tickEnter.select(\"text\").attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding));\n          tickUpdate.select(\"line\").attr(\"x2\", -tickMajorSize).attr(\"y2\", 0);\n          tickUpdate.select(\"text\").attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding)).attr(\"y\", 0).attr(\"dy\", \".32em\").attr(\"text-anchor\", \"end\");\n          pathUpdate.attr(\"d\", \"M\" + -tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + -tickEndSize);\n          break;\n        }\n        case \"right\": {\n          tickTransform = d3_svg_axisY;\n          subtickEnter.attr(\"x2\", tickMinorSize);\n          subtickUpdate.attr(\"x2\", tickMinorSize).attr(\"y2\", 0);\n          tickEnter.select(\"line\").attr(\"x2\", tickMajorSize);\n          tickEnter.select(\"text\").attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding);\n          tickUpdate.select(\"line\").attr(\"x2\", tickMajorSize).attr(\"y2\", 0);\n          tickUpdate.select(\"text\").attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding).attr(\"y\", 0).attr(\"dy\", \".32em\").attr(\"text-anchor\", \"start\");\n          pathUpdate.attr(\"d\", \"M\" + tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + tickEndSize);\n          break;\n        }\n      }\n\n      // For quantitative scales:\n      // - enter new ticks from the old scale\n      // - exit old ticks to the new scale\n      if (scale.ticks) {\n        tickEnter.call(tickTransform, scale0);\n        tickUpdate.call(tickTransform, scale1);\n        tickExit.call(tickTransform, scale1);\n        subtickEnter.call(tickTransform, scale0);\n        subtickUpdate.call(tickTransform, scale1);\n        subtickExit.call(tickTransform, scale1);\n      }\n\n      // For ordinal scales:\n      // - any entering ticks are undefined in the old scale\n      // - any exiting ticks are undefined in the new scale\n      // Therefore, we only need to transition updating ticks.\n      else {\n        var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };\n        tickEnter.call(tickTransform, x);\n        tickUpdate.call(tickTransform, x);\n      }\n    });\n  }\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = x;\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x;\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments_;\n    tickArguments_ = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormat_;\n    tickFormat_ = x;\n    return axis;\n  };\n\n  axis.tickSize = function(x, y, z) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1;\n    tickMajorSize = +x;\n    tickMinorSize = n > 1 ? +y : tickMajorSize;\n    tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    tickPadding = +x;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n\n  return axis;\n};\n\nfunction d3_svg_axisX(selection, x) {\n  selection.attr(\"transform\", function(d) { return \"translate(\" + x(d) + \",0)\"; });\n}\n\nfunction d3_svg_axisY(selection, y) {\n  selection.attr(\"transform\", function(d) { return \"translate(0,\" + y(d) + \")\"; });\n}\n\nfunction d3_svg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = d3_scaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\nd3.svg.brush = function() {\n  var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"),\n      x = null, // x-scale, optional\n      y = null, // y-scale, optional\n      resizes = d3_svg_brushResizes[0],\n      extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1], in pixels (integers)\n      extentDomain; // the extent in data space, lazily created\n\n  function brush(g) {\n    g.each(function() {\n      var g = d3.select(this),\n          bg = g.selectAll(\".background\").data([0]),\n          fg = g.selectAll(\".extent\").data([0]),\n          tz = g.selectAll(\".resize\").data(resizes, String),\n          e;\n\n      // Prepare the brush container for events.\n      g\n          .style(\"pointer-events\", \"all\")\n          .on(\"mousedown.brush\", brushstart)\n          .on(\"touchstart.brush\", brushstart);\n\n      // An invisible, mouseable area for starting a new brush.\n      bg.enter().append(\"rect\")\n          .attr(\"class\", \"background\")\n          .style(\"visibility\", \"hidden\")\n          .style(\"cursor\", \"crosshair\");\n\n      // The visible brush extent; style this as you like!\n      fg.enter().append(\"rect\")\n          .attr(\"class\", \"extent\")\n          .style(\"cursor\", \"move\");\n\n      // More invisible rects for resizing the extent.\n      tz.enter().append(\"g\")\n          .attr(\"class\", function(d) { return \"resize \" + d; })\n          .style(\"cursor\", function(d) { return d3_svg_brushCursor[d]; })\n        .append(\"rect\")\n          .attr(\"x\", function(d) { return /[ew]$/.test(d) ? -3 : null; })\n          .attr(\"y\", function(d) { return /^[ns]/.test(d) ? -3 : null; })\n          .attr(\"width\", 6)\n          .attr(\"height\", 6)\n          .style(\"visibility\", \"hidden\");\n\n      // Show or hide the resizers.\n      tz.style(\"display\", brush.empty() ? \"none\" : null);\n\n      // Remove any superfluous resizers.\n      tz.exit().remove();\n\n      // Initialize the background to fill the defined range.\n      // If the range isn't defined, you can post-process.\n      if (x) {\n        e = d3_scaleRange(x);\n        bg.attr(\"x\", e[0]).attr(\"width\", e[1] - e[0]);\n        redrawX(g);\n      }\n      if (y) {\n        e = d3_scaleRange(y);\n        bg.attr(\"y\", e[0]).attr(\"height\", e[1] - e[0]);\n        redrawY(g);\n      }\n      redraw(g);\n    });\n  }\n\n  function redraw(g) {\n    g.selectAll(\".resize\").attr(\"transform\", function(d) {\n      return \"translate(\" + extent[+/e$/.test(d)][0] + \",\" + extent[+/^s/.test(d)][1] + \")\";\n    });\n  }\n\n  function redrawX(g) {\n    g.select(\".extent\").attr(\"x\", extent[0][0]);\n    g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", extent[1][0] - extent[0][0]);\n  }\n\n  function redrawY(g) {\n    g.select(\".extent\").attr(\"y\", extent[0][1]);\n    g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", extent[1][1] - extent[0][1]);\n  }\n\n  function brushstart() {\n    var target = this,\n        eventTarget = d3.select(d3.event.target),\n        event_ = event.of(target, arguments),\n        g = d3.select(target),\n        resizing = eventTarget.datum(),\n        resizingX = !/^(n|s)$/.test(resizing) && x,\n        resizingY = !/^(e|w)$/.test(resizing) && y,\n        dragging = eventTarget.classed(\"extent\"),\n        center,\n        origin = mouse(),\n        offset;\n\n    var w = d3.select(window)\n        .on(\"mousemove.brush\", brushmove)\n        .on(\"mouseup.brush\", brushend)\n        .on(\"touchmove.brush\", brushmove)\n        .on(\"touchend.brush\", brushend)\n        .on(\"keydown.brush\", keydown)\n        .on(\"keyup.brush\", keyup);\n\n    // If the extent was clicked on, drag rather than brush;\n    // store the point between the mouse and extent origin instead.\n    if (dragging) {\n      origin[0] = extent[0][0] - origin[0];\n      origin[1] = extent[0][1] - origin[1];\n    }\n\n    // If a resizer was clicked on, record which side is to be resized.\n    // Also, set the origin to the opposite side.\n    else if (resizing) {\n      var ex = +/w$/.test(resizing),\n          ey = +/^n/.test(resizing);\n      offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];\n      origin[0] = extent[ex][0];\n      origin[1] = extent[ey][1];\n    }\n\n    // If the ALT key is down when starting a brush, the center is at the mouse.\n    else if (d3.event.altKey) center = origin.slice();\n\n    // Propagate the active cursor to the body for the drag duration.\n    g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n    d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n\n    // Notify listeners.\n    event_({type: \"brushstart\"});\n    brushmove();\n    d3_eventCancel();\n\n    function mouse() {\n      var touches = d3.event.changedTouches;\n      return touches ? d3.touches(target, touches)[0] : d3.mouse(target);\n    }\n\n    function keydown() {\n      if (d3.event.keyCode == 32) {\n        if (!dragging) {\n          center = null;\n          origin[0] -= extent[1][0];\n          origin[1] -= extent[1][1];\n          dragging = 2;\n        }\n        d3_eventCancel();\n      }\n    }\n\n    function keyup() {\n      if (d3.event.keyCode == 32 && dragging == 2) {\n        origin[0] += extent[1][0];\n        origin[1] += extent[1][1];\n        dragging = 0;\n        d3_eventCancel();\n      }\n    }\n\n    function brushmove() {\n      var point = mouse(),\n          moved = false;\n\n      // Preserve the offset for thick resizers.\n      if (offset) {\n        point[0] += offset[0];\n        point[1] += offset[1];\n      }\n\n      if (!dragging) {\n\n        // If needed, determine the center from the current extent.\n        if (d3.event.altKey) {\n          if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];\n\n          // Update the origin, for when the ALT key is released.\n          origin[0] = extent[+(point[0] < center[0])][0];\n          origin[1] = extent[+(point[1] < center[1])][1];\n        }\n\n        // When the ALT key is released, we clear the center.\n        else center = null;\n      }\n\n      // Update the brush extent for each dimension.\n      if (resizingX && move1(point, x, 0)) {\n        redrawX(g);\n        moved = true;\n      }\n      if (resizingY && move1(point, y, 1)) {\n        redrawY(g);\n        moved = true;\n      }\n\n      // Final redraw and notify listeners.\n      if (moved) {\n        redraw(g);\n        event_({type: \"brush\", mode: dragging ? \"move\" : \"resize\"});\n      }\n    }\n\n    function move1(point, scale, i) {\n      var range = d3_scaleRange(scale),\n          r0 = range[0],\n          r1 = range[1],\n          position = origin[i],\n          size = extent[1][i] - extent[0][i],\n          min,\n          max;\n\n      // When dragging, reduce the range by the extent size and position.\n      if (dragging) {\n        r0 -= position;\n        r1 -= size + position;\n      }\n\n      // Clamp the point so that the extent fits within the range extent.\n      min = Math.max(r0, Math.min(r1, point[i]));\n\n      // Compute the new extent bounds.\n      if (dragging) {\n        max = (min += position) + size;\n      } else {\n\n        // If the ALT key is pressed, then preserve the center of the extent.\n        if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n\n        // Compute the min and max of the position and point.\n        if (position < min) {\n          max = min;\n          min = position;\n        } else {\n          max = position;\n        }\n      }\n\n      // Update the stored bounds.\n      if (extent[0][i] !== min || extent[1][i] !== max) {\n        extentDomain = null;\n        extent[0][i] = min;\n        extent[1][i] = max;\n        return true;\n      }\n    }\n\n    function brushend() {\n      brushmove();\n\n      // reset the cursor styles\n      g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n      d3.select(\"body\").style(\"cursor\", null);\n\n      w .on(\"mousemove.brush\", null)\n        .on(\"mouseup.brush\", null)\n        .on(\"touchmove.brush\", null)\n        .on(\"touchend.brush\", null)\n        .on(\"keydown.brush\", null)\n        .on(\"keyup.brush\", null);\n\n      event_({type: \"brushend\"});\n      d3_eventCancel();\n    }\n  }\n\n  brush.x = function(z) {\n    if (!arguments.length) return x;\n    x = z;\n    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!\n    return brush;\n  };\n\n  brush.y = function(z) {\n    if (!arguments.length) return y;\n    y = z;\n    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!\n    return brush;\n  };\n\n  brush.extent = function(z) {\n    var x0, x1, y0, y1, t;\n\n    // Invert the pixel extent to data-space.\n    if (!arguments.length) {\n      z = extentDomain || extent;\n      if (x) {\n        x0 = z[0][0], x1 = z[1][0];\n        if (!extentDomain) {\n          x0 = extent[0][0], x1 = extent[1][0];\n          if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n          if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        }\n      }\n      if (y) {\n        y0 = z[0][1], y1 = z[1][1];\n        if (!extentDomain) {\n          y0 = extent[0][1], y1 = extent[1][1];\n          if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n          if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        }\n      }\n      return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];\n    }\n\n    // Scale the data-space extent to pixels.\n    extentDomain = [[0, 0], [0, 0]];\n    if (x) {\n      x0 = z[0], x1 = z[1];\n      if (y) x0 = x0[0], x1 = x1[0];\n      extentDomain[0][0] = x0, extentDomain[1][0] = x1;\n      if (x.invert) x0 = x(x0), x1 = x(x1);\n      if (x1 < x0) t = x0, x0 = x1, x1 = t;\n      extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;\n    }\n    if (y) {\n      y0 = z[0], y1 = z[1];\n      if (x) y0 = y0[1], y1 = y1[1];\n      extentDomain[0][1] = y0, extentDomain[1][1] = y1;\n      if (y.invert) y0 = y(y0), y1 = y(y1);\n      if (y1 < y0) t = y0, y0 = y1, y1 = t;\n      extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;\n    }\n\n    return brush;\n  };\n\n  brush.clear = function() {\n    extentDomain = null;\n    extent[0][0] =\n    extent[0][1] =\n    extent[1][0] =\n    extent[1][1] = 0;\n    return brush;\n  };\n\n  brush.empty = function() {\n    return (x && extent[0][0] === extent[1][0])\n        || (y && extent[0][1] === extent[1][1]);\n  };\n\n  return d3.rebind(brush, event, \"on\");\n};\n\nvar d3_svg_brushCursor = {\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar d3_svg_brushResizes = [\n  [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"],\n  [\"e\", \"w\"],\n  [\"n\", \"s\"],\n  []\n];\nd3.behavior = {};\n// TODO Track touch points by identifier.\n\nd3.behavior.drag = function() {\n  var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n      origin = null;\n\n  function drag() {\n    this.on(\"mousedown.drag\", mousedown)\n        .on(\"touchstart.drag\", mousedown);\n  }\n\n  function mousedown() {\n    var target = this,\n        event_ = event.of(target, arguments),\n        eventTarget = d3.event.target,\n        offset,\n        origin_ = point(),\n        moved = 0;\n\n    var w = d3.select(window)\n        .on(\"mousemove.drag\", dragmove)\n        .on(\"touchmove.drag\", dragmove)\n        .on(\"mouseup.drag\", dragend, true)\n        .on(\"touchend.drag\", dragend, true);\n\n    if (origin) {\n      offset = origin.apply(target, arguments);\n      offset = [offset.x - origin_[0], offset.y - origin_[1]];\n    } else {\n      offset = [0, 0];\n    }\n\n    event_({type: \"dragstart\"});\n\n    function point() {\n      var p = target.parentNode,\n          t = d3.event.changedTouches;\n      return t ? d3.touches(p, t)[0] : d3.mouse(p);\n    }\n\n    function dragmove() {\n      if (!target.parentNode) return dragend(); // target removed from DOM\n\n      var p = point(),\n          dx = p[0] - origin_[0],\n          dy = p[1] - origin_[1];\n\n      moved |= dx | dy;\n      origin_ = p;\n      d3_eventCancel();\n\n      event_({type: \"drag\", x: p[0] + offset[0], y: p[1] + offset[1], dx: dx, dy: dy});\n    }\n\n    function dragend() {\n      event_({type: \"dragend\"});\n\n      // if moved, prevent the mouseup (and possibly click) from propagating\n      if (moved) {\n        d3_eventCancel();\n        if (d3.event.target === eventTarget) w.on(\"click.drag\", click, true);\n      }\n\n      w .on(\"mousemove.drag\", null)\n        .on(\"touchmove.drag\", null)\n        .on(\"mouseup.drag\", null)\n        .on(\"touchend.drag\", null);\n    }\n\n    // prevent the subsequent click from propagating (e.g., for anchors)\n    function click() {\n      d3_eventCancel();\n      w.on(\"click.drag\", null);\n    }\n  }\n\n  drag.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    return drag;\n  };\n\n  return d3.rebind(drag, event, \"on\");\n};\nd3.behavior.zoom = function() {\n  var translate = [0, 0],\n      translate0, // translate when we started zooming (to avoid drift)\n      scale = 1,\n      scale0, // scale when we started touching\n      scaleExtent = d3_behavior_zoomInfinity,\n      event = d3_eventDispatch(zoom, \"zoom\"),\n      x0,\n      x1,\n      y0,\n      y1,\n      touchtime; // time of last touchstart (to detect double-tap)\n\n  function zoom() {\n    this\n        .on(\"mousedown.zoom\", mousedown)\n        .on(\"mousewheel.zoom\", mousewheel)\n        .on(\"mousemove.zoom\", mousemove)\n        .on(\"DOMMouseScroll.zoom\", mousewheel)\n        .on(\"dblclick.zoom\", dblclick)\n        .on(\"touchstart.zoom\", touchstart)\n        .on(\"touchmove.zoom\", touchmove)\n        .on(\"touchend.zoom\", touchstart);\n  }\n\n  zoom.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = x.map(Number);\n    return zoom;\n  };\n\n  zoom.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return zoom;\n  };\n\n  zoom.scaleExtent = function(x) {\n    if (!arguments.length) return scaleExtent;\n    scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);\n    return zoom;\n  };\n\n  zoom.x = function(z) {\n    if (!arguments.length) return x1;\n    x1 = z;\n    x0 = z.copy();\n    return zoom;\n  };\n\n  zoom.y = function(z) {\n    if (!arguments.length) return y1;\n    y1 = z;\n    y0 = z.copy();\n    return zoom;\n  };\n\n  function location(p) {\n    return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];\n  }\n\n  function point(l) {\n    return [l[0] * scale + translate[0], l[1] * scale + translate[1]];\n  }\n\n  function scaleTo(s) {\n    scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n  }\n\n  function translateTo(p, l) {\n    l = point(l);\n    translate[0] += p[0] - l[0];\n    translate[1] += p[1] - l[1];\n  }\n\n  function dispatch(event) {\n    if (x1) x1.domain(x0.range().map(function(x) { return (x - translate[0]) / scale; }).map(x0.invert));\n    if (y1) y1.domain(y0.range().map(function(y) { return (y - translate[1]) / scale; }).map(y0.invert));\n    d3.event.preventDefault();\n    event({type: \"zoom\", scale: scale, translate: translate});\n  }\n\n  function mousedown() {\n    var target = this,\n        event_ = event.of(target, arguments),\n        eventTarget = d3.event.target,\n        moved = 0,\n        w = d3.select(window).on(\"mousemove.zoom\", mousemove).on(\"mouseup.zoom\", mouseup),\n        l = location(d3.mouse(target));\n\n    window.focus();\n    d3_eventCancel();\n\n    function mousemove() {\n      moved = 1;\n      translateTo(d3.mouse(target), l);\n      dispatch(event_);\n    }\n\n    function mouseup() {\n      if (moved) d3_eventCancel();\n      w.on(\"mousemove.zoom\", null).on(\"mouseup.zoom\", null);\n      if (moved && d3.event.target === eventTarget) w.on(\"click.zoom\", click);\n    }\n\n    function click() {\n      d3_eventCancel();\n      w.on(\"click.zoom\", null);\n    }\n  }\n\n  function mousewheel() {\n    if (!translate0) translate0 = location(d3.mouse(this));\n    scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);\n    translateTo(d3.mouse(this), translate0);\n    dispatch(event.of(this, arguments));\n  }\n\n  function mousemove() {\n    translate0 = null;\n  }\n\n  function dblclick() {\n    var p = d3.mouse(this), l = location(p);\n    scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);\n    translateTo(p, l);\n    dispatch(event.of(this, arguments));\n  }\n\n  function touchstart() {\n    var touches = d3.touches(this),\n        now = Date.now();\n\n    scale0 = scale;\n    translate0 = {};\n    touches.forEach(function(t) { translate0[t.identifier] = location(t); });\n    d3_eventCancel();\n\n    if ((touches.length === 1) && (now - touchtime < 500)) { // dbltap\n      var p = touches[0], l = location(touches[0]);\n      scaleTo(scale * 2);\n      translateTo(p, l);\n      dispatch(event.of(this, arguments));\n    }\n    touchtime = now;\n  }\n\n  function touchmove() {\n    var touches = d3.touches(this),\n        p0 = touches[0],\n        l0 = translate0[p0.identifier];\n    if (p1 = touches[1]) {\n      var p1, l1 = translate0[p1.identifier];\n      p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n      scaleTo(d3.event.scale * scale0);\n    }\n    translateTo(p0, l0);\n    dispatch(event.of(this, arguments));\n  }\n\n  return d3.rebind(zoom, event, \"on\");\n};\n\nvar d3_behavior_zoomDiv, // for interpreting mousewheel events\n    d3_behavior_zoomInfinity = [0, Infinity]; // default scale extent\n\nfunction d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta;\n}\nd3.layout = {};\n// Implements hierarchical edge bundling using Holten's algorithm. For each\n// input link, a path is computed that travels through the tree, up the parent\n// hierarchy to the least common ancestor, and then back down to the destination\n// node. Each path is simply an array of nodes.\nd3.layout.bundle = function() {\n  return function(links) {\n    var paths = [],\n        i = -1,\n        n = links.length;\n    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n    return paths;\n  };\n};\n\nfunction d3_layout_bundlePath(link) {\n  var start = link.source,\n      end = link.target,\n      lca = d3_layout_bundleLeastCommonAncestor(start, end),\n      points = [start];\n  while (start !== lca) {\n    start = start.parent;\n    points.push(start);\n  }\n  var k = points.length;\n  while (end !== lca) {\n    points.splice(k, 0, end);\n    end = end.parent;\n  }\n  return points;\n}\n\nfunction d3_layout_bundleAncestors(node) {\n  var ancestors = [],\n      parent = node.parent;\n  while (parent != null) {\n    ancestors.push(node);\n    node = parent;\n    parent = parent.parent;\n  }\n  ancestors.push(node);\n  return ancestors;\n}\n\nfunction d3_layout_bundleLeastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = d3_layout_bundleAncestors(a),\n      bNodes = d3_layout_bundleAncestors(b),\n      aNode = aNodes.pop(),\n      bNode = bNodes.pop(),\n      sharedNode = null;\n  while (aNode === bNode) {\n    sharedNode = aNode;\n    aNode = aNodes.pop();\n    bNode = bNodes.pop();\n  }\n  return sharedNode;\n}\nd3.layout.chord = function() {\n  var chord = {},\n      chords,\n      groups,\n      matrix,\n      n,\n      padding = 0,\n      sortGroups,\n      sortSubgroups,\n      sortChords;\n\n  function relayout() {\n    var subgroups = {},\n        groupSums = [],\n        groupIndex = d3.range(n),\n        subgroupIndex = [],\n        k,\n        x,\n        x0,\n        i,\n        j;\n\n    chords = [];\n    groups = [];\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(d3.range(n));\n      k += x;\n    }\n\n    // Sort groups\n    if (sortGroups) {\n      groupIndex.sort(function(a, b) {\n        return sortGroups(groupSums[a], groupSums[b]);\n      });\n    }\n\n    // Sort subgroups\n    if (sortSubgroups) {\n      subgroupIndex.forEach(function(d, i) {\n        d.sort(function(a, b) {\n          return sortSubgroups(matrix[i][a], matrix[i][b]);\n        });\n      });\n    }\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified.\n    // TODO Allow padding to be specified as percentage?\n    k = (2 * Math.PI - padding * n) / k;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[di][j],\n            v = matrix[di][dj],\n            a0 = x,\n            a1 = x += v * k;\n        subgroups[di + \"-\" + dj] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups.push({\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: (x - x0) / k\n      });\n      x += padding;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[i + \"-\" + j],\n            target = subgroups[j + \"-\" + i];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    if (sortChords) resort();\n  }\n\n  function resort() {\n    chords.sort(function(a, b) {\n      return sortChords(\n          (a.source.value + a.target.value) / 2,\n          (b.source.value + b.target.value) / 2);\n    });\n  }\n\n  chord.matrix = function(x) {\n    if (!arguments.length) return matrix;\n    n = (matrix = x) && matrix.length;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.padding = function(x) {\n    if (!arguments.length) return padding;\n    padding = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortGroups = function(x) {\n    if (!arguments.length) return sortGroups;\n    sortGroups = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortSubgroups = function(x) {\n    if (!arguments.length) return sortSubgroups;\n    sortSubgroups = x;\n    chords = null;\n    return chord;\n  };\n\n  chord.sortChords = function(x) {\n    if (!arguments.length) return sortChords;\n    sortChords = x;\n    if (chords) resort();\n    return chord;\n  };\n\n  chord.chords = function() {\n    if (!chords) relayout();\n    return chords;\n  };\n\n  chord.groups = function() {\n    if (!groups) relayout();\n    return groups;\n  };\n\n  return chord;\n};\n// A rudimentary force layout using Gauss-Seidel.\nd3.layout.force = function() {\n  var force = {},\n      event = d3.dispatch(\"start\", \"tick\", \"end\"),\n      size = [1, 1],\n      drag,\n      alpha,\n      friction = .9,\n      linkDistance = d3_layout_forceLinkDistance,\n      linkStrength = d3_layout_forceLinkStrength,\n      charge = -30,\n      gravity = .1,\n      theta = .8,\n      interval,\n      nodes = [],\n      links = [],\n      distances,\n      strengths,\n      charges;\n\n  function repulse(node) {\n    return function(quad, x1, y1, x2, y2) {\n      if (quad.point !== node) {\n        var dx = quad.cx - node.x,\n            dy = quad.cy - node.y,\n            dn = 1 / Math.sqrt(dx * dx + dy * dy);\n\n        /* Barnes-Hut criterion. */\n        if ((x2 - x1) * dn < theta) {\n          var k = quad.charge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n          return true;\n        }\n\n        if (quad.point && isFinite(dn)) {\n          var k = quad.pointCharge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n        }\n      }\n      return !quad.charge;\n    };\n  }\n\n  force.tick = function() {\n    // simulated annealing, basically\n    if ((alpha *= .99) < .005) {\n      event.end({type: \"end\", alpha: alpha = 0});\n      return true;\n    }\n\n    var n = nodes.length,\n        m = links.length,\n        q,\n        i, // current index\n        o, // current object\n        s, // current source\n        t, // current target\n        l, // current distance\n        k, // current force\n        x, // x-distance\n        y; // y-distance\n\n    // gauss-seidel relaxation for links\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      s = o.source;\n      t = o.target;\n      x = t.x - s.x;\n      y = t.y - s.y;\n      if (l = (x * x + y * y)) {\n        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n        x *= l;\n        y *= l;\n        t.x -= x * (k = s.weight / (t.weight + s.weight));\n        t.y -= y * k;\n        s.x += x * (k = 1 - k);\n        s.y += y * k;\n      }\n    }\n\n    // apply gravity forces\n    if (k = alpha * gravity) {\n      x = size[0] / 2;\n      y = size[1] / 2;\n      i = -1; if (k) while (++i < n) {\n        o = nodes[i];\n        o.x += (x - o.x) * k;\n        o.y += (y - o.y) * k;\n      }\n    }\n\n    // compute quadtree center of mass and apply charge forces\n    if (charge) {\n      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n      i = -1; while (++i < n) {\n        if (!(o = nodes[i]).fixed) {\n          q.visit(repulse(o));\n        }\n      }\n    }\n\n    // position verlet integration\n    i = -1; while (++i < n) {\n      o = nodes[i];\n      if (o.fixed) {\n        o.x = o.px;\n        o.y = o.py;\n      } else {\n        o.x -= (o.px - (o.px = o.x)) * friction;\n        o.y -= (o.py - (o.py = o.y)) * friction;\n      }\n    }\n\n    event.tick({type: \"tick\", alpha: alpha});\n  };\n\n  force.nodes = function(x) {\n    if (!arguments.length) return nodes;\n    nodes = x;\n    return force;\n  };\n\n  force.links = function(x) {\n    if (!arguments.length) return links;\n    links = x;\n    return force;\n  };\n\n  force.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return force;\n  };\n\n  force.linkDistance = function(x) {\n    if (!arguments.length) return linkDistance;\n    linkDistance = d3.functor(x);\n    return force;\n  };\n\n  // For backwards-compatibility.\n  force.distance = force.linkDistance;\n\n  force.linkStrength = function(x) {\n    if (!arguments.length) return linkStrength;\n    linkStrength = d3.functor(x);\n    return force;\n  };\n\n  force.friction = function(x) {\n    if (!arguments.length) return friction;\n    friction = x;\n    return force;\n  };\n\n  force.charge = function(x) {\n    if (!arguments.length) return charge;\n    charge = typeof x === \"function\" ? x : +x;\n    return force;\n  };\n\n  force.gravity = function(x) {\n    if (!arguments.length) return gravity;\n    gravity = x;\n    return force;\n  };\n\n  force.theta = function(x) {\n    if (!arguments.length) return theta;\n    theta = x;\n    return force;\n  };\n\n  force.alpha = function(x) {\n    if (!arguments.length) return alpha;\n\n    if (alpha) { // if we're already running\n      if (x > 0) alpha = x; // we might keep it hot\n      else alpha = 0; // or, next tick will dispatch \"end\"\n    } else if (x > 0) { // otherwise, fire it up!\n      event.start({type: \"start\", alpha: alpha = x});\n      d3.timer(force.tick);\n    }\n\n    return force;\n  };\n\n  force.start = function() {\n    var i,\n        j,\n        n = nodes.length,\n        m = links.length,\n        w = size[0],\n        h = size[1],\n        neighbors,\n        o;\n\n    for (i = 0; i < n; ++i) {\n      (o = nodes[i]).index = i;\n      o.weight = 0;\n    }\n\n    distances = [];\n    strengths = [];\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      if (typeof o.source == \"number\") o.source = nodes[o.source];\n      if (typeof o.target == \"number\") o.target = nodes[o.target];\n      distances[i] = linkDistance.call(this, o, i);\n      strengths[i] = linkStrength.call(this, o, i);\n      ++o.source.weight;\n      ++o.target.weight;\n    }\n\n    for (i = 0; i < n; ++i) {\n      o = nodes[i];\n      if (isNaN(o.x)) o.x = position(\"x\", w);\n      if (isNaN(o.y)) o.y = position(\"y\", h);\n      if (isNaN(o.px)) o.px = o.x;\n      if (isNaN(o.py)) o.py = o.y;\n    }\n\n    charges = [];\n    if (typeof charge === \"function\") {\n      for (i = 0; i < n; ++i) {\n        charges[i] = +charge.call(this, nodes[i], i);\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        charges[i] = charge;\n      }\n    }\n\n    // initialize node position based on first neighbor\n    function position(dimension, size) {\n      var neighbors = neighbor(i),\n          j = -1,\n          m = neighbors.length,\n          x;\n      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;\n      return Math.random() * size;\n    }\n\n    // initialize neighbors lazily\n    function neighbor() {\n      if (!neighbors) {\n        neighbors = [];\n        for (j = 0; j < n; ++j) {\n          neighbors[j] = [];\n        }\n        for (j = 0; j < m; ++j) {\n          var o = links[j];\n          neighbors[o.source.index].push(o.target);\n          neighbors[o.target.index].push(o.source);\n        }\n      }\n      return neighbors[i];\n    }\n\n    return force.resume();\n  };\n\n  force.resume = function() {\n    return force.alpha(.1);\n  };\n\n  force.stop = function() {\n    return force.alpha(0);\n  };\n\n  // use `node.call(force.drag)` to make nodes draggable\n  force.drag = function() {\n    if (!drag) drag = d3.behavior.drag()\n        .origin(Object)\n        .on(\"dragstart\", dragstart)\n        .on(\"drag\", d3_layout_forceDrag)\n        .on(\"dragend\", d3_layout_forceDragEnd);\n\n    this.on(\"mouseover.force\", d3_layout_forceDragOver)\n        .on(\"mouseout.force\", d3_layout_forceDragOut)\n        .call(drag);\n  };\n\n  function dragstart(d) {\n    d3_layout_forceDragOver(d3_layout_forceDragNode = d);\n    d3_layout_forceDragForce = force;\n  }\n\n  return d3.rebind(force, event, \"on\");\n};\n\nvar d3_layout_forceDragForce,\n    d3_layout_forceDragNode;\n\nfunction d3_layout_forceDragOver(d) {\n  d.fixed |= 2;\n}\n\nfunction d3_layout_forceDragOut(d) {\n  if (d !== d3_layout_forceDragNode) d.fixed &= 1;\n}\n\nfunction d3_layout_forceDragEnd() {\n  d3_layout_forceDragNode.fixed &= 1;\n  d3_layout_forceDragForce = d3_layout_forceDragNode = null;\n}\n\nfunction d3_layout_forceDrag() {\n  d3_layout_forceDragNode.px = d3.event.x;\n  d3_layout_forceDragNode.py = d3.event.y;\n  d3_layout_forceDragForce.resume(); // restart annealing\n}\n\nfunction d3_layout_forceAccumulate(quad, alpha, charges) {\n  var cx = 0,\n      cy = 0;\n  quad.charge = 0;\n  if (!quad.leaf) {\n    var nodes = quad.nodes,\n        n = nodes.length,\n        i = -1,\n        c;\n    while (++i < n) {\n      c = nodes[i];\n      if (c == null) continue;\n      d3_layout_forceAccumulate(c, alpha, charges);\n      quad.charge += c.charge;\n      cx += c.charge * c.cx;\n      cy += c.charge * c.cy;\n    }\n  }\n  if (quad.point) {\n    // jitter internal nodes that are coincident\n    if (!quad.leaf) {\n      quad.point.x += Math.random() - .5;\n      quad.point.y += Math.random() - .5;\n    }\n    var k = alpha * charges[quad.point.index];\n    quad.charge += quad.pointCharge = k;\n    cx += k * quad.point.x;\n    cy += k * quad.point.y;\n  }\n  quad.cx = cx / quad.charge;\n  quad.cy = cy / quad.charge;\n}\n\nfunction d3_layout_forceLinkDistance(link) {\n  return 20;\n}\n\nfunction d3_layout_forceLinkStrength(link) {\n  return 1;\n}\nd3.layout.partition = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      size = [1, 1]; // width, height\n\n  function position(node, x, dx, dy) {\n    var children = node.children;\n    node.x = x;\n    node.y = node.depth * dy;\n    node.dx = dx;\n    node.dy = dy;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n,\n          c,\n          d;\n      dx = node.value ? dx / node.value : 0;\n      while (++i < n) {\n        position(c = children[i], x, d = c.value * dx, dy);\n        x += d;\n      }\n    }\n  }\n\n  function depth(node) {\n    var children = node.children,\n        d = 0;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n;\n      while (++i < n) d = Math.max(d, depth(children[i]));\n    }\n    return 1 + d;\n  }\n\n  function partition(d, i) {\n    var nodes = hierarchy.call(this, d, i);\n    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n    return nodes;\n  }\n\n  partition.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return partition;\n  };\n\n  return d3_layout_hierarchyRebind(partition, hierarchy);\n};\nd3.layout.pie = function() {\n  var value = Number,\n      sort = d3_layout_pieSortByValue,\n      startAngle = 0,\n      endAngle = 2 * Math.PI;\n\n  function pie(data, i) {\n\n    // Compute the numeric values for each data element.\n    var values = data.map(function(d, i) { return +value.call(pie, d, i); });\n\n    // Compute the start angle.\n    var a = +(typeof startAngle === \"function\"\n        ? startAngle.apply(this, arguments)\n        : startAngle);\n\n    // Compute the angular scale factor: from value to radians.\n    var k = ((typeof endAngle === \"function\"\n        ? endAngle.apply(this, arguments)\n        : endAngle) - startAngle)\n        / d3.sum(values);\n\n    // Optionally sort the data.\n    var index = d3.range(data.length);\n    if (sort != null) index.sort(sort === d3_layout_pieSortByValue\n        ? function(i, j) { return values[j] - values[i]; }\n        : function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs!\n    // They are stored in the original data's order.\n    var arcs = [];\n    index.forEach(function(i) {\n      arcs[i] = {\n        data: data[i],\n        value: d = values[i],\n        startAngle: a,\n        endAngle: a += d * k\n      };\n    });\n    return arcs;\n  }\n\n  /**\n   * Specifies the value function *x*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `Number`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  pie.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return pie;\n  };\n\n  /**\n   * Specifies a sort comparison operator *x*. The comparator is passed two data\n   * elements from the data array, a and b; it returns a negative value if a is\n   * less than b, a positive value if a is greater than b, and zero if a equals\n   * b.\n   */\n  pie.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall start angle of the pie chart. Defaults to 0. The\n   * start angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.startAngle = function(x) {\n    if (!arguments.length) return startAngle;\n    startAngle = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall end angle of the pie chart. Defaults to 2. The\n   * end angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.endAngle = function(x) {\n    if (!arguments.length) return endAngle;\n    endAngle = x;\n    return pie;\n  };\n\n  return pie;\n};\n\nvar d3_layout_pieSortByValue = {};\n// data is two-dimensional array of x,y; we populate y0\nd3.layout.stack = function() {\n  var values = Object,\n      order = d3_layout_stackOrderDefault,\n      offset = d3_layout_stackOffsetZero,\n      out = d3_layout_stackOut,\n      x = d3_layout_stackX,\n      y = d3_layout_stackY;\n\n  function stack(data, index) {\n\n    // Convert series to canonical two-dimensional representation.\n    var series = data.map(function(d, i) {\n      return values.call(stack, d, i);\n    });\n\n    // Convert each series to canonical [[x,y]] representation.\n    var points = series.map(function(d, i) {\n      return d.map(function(v, i) {\n        return [x.call(stack, v, i), y.call(stack, v, i)];\n      });\n    });\n\n    // Compute the order of series, and permute them.\n    var orders = order.call(stack, points, index);\n    series = d3.permute(series, orders);\n    points = d3.permute(points, orders);\n\n    // Compute the baseline\n    var offsets = offset.call(stack, points, index);\n\n    // And propagate it to other series.\n    var n = series.length,\n        m = series[0].length,\n        i,\n        j,\n        o;\n    for (j = 0; j < m; ++j) {\n      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n      for (i = 1; i < n; ++i) {\n        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n      }\n    }\n\n    return data;\n  }\n\n  stack.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return stack;\n  };\n\n  stack.order = function(x) {\n    if (!arguments.length) return order;\n    order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n    return stack;\n  };\n\n  stack.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n    return stack;\n  };\n\n  stack.x = function(z) {\n    if (!arguments.length) return x;\n    x = z;\n    return stack;\n  };\n\n  stack.y = function(z) {\n    if (!arguments.length) return y;\n    y = z;\n    return stack;\n  };\n\n  stack.out = function(z) {\n    if (!arguments.length) return out;\n    out = z;\n    return stack;\n  };\n\n  return stack;\n}\n\nfunction d3_layout_stackX(d) {\n  return d.x;\n}\n\nfunction d3_layout_stackY(d) {\n  return d.y;\n}\n\nfunction d3_layout_stackOut(d, y0, y) {\n  d.y0 = y0;\n  d.y = y;\n}\n\nvar d3_layout_stackOrders = d3.map({\n\n  \"inside-out\": function(data) {\n    var n = data.length,\n        i,\n        j,\n        max = data.map(d3_layout_stackMaxIndex),\n        sums = data.map(d3_layout_stackReduceSum),\n        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),\n        top = 0,\n        bottom = 0,\n        tops = [],\n        bottoms = [];\n    for (i = 0; i < n; ++i) {\n      j = index[i];\n      if (top < bottom) {\n        top += sums[j];\n        tops.push(j);\n      } else {\n        bottom += sums[j];\n        bottoms.push(j);\n      }\n    }\n    return bottoms.reverse().concat(tops);\n  },\n\n  \"reverse\": function(data) {\n    return d3.range(data.length).reverse();\n  },\n\n  \"default\": d3_layout_stackOrderDefault\n\n});\n\nvar d3_layout_stackOffsets = d3.map({\n\n  \"silhouette\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        sums = [],\n        max = 0,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o > max) max = o;\n      sums.push(o);\n    }\n    for (j = 0; j < m; ++j) {\n      y0[j] = (max - sums[j]) / 2;\n    }\n    return y0;\n  },\n\n  \"wiggle\": function(data) {\n    var n = data.length,\n        x = data[0],\n        m = x.length,\n        max = 0,\n        i,\n        j,\n        k,\n        s1,\n        s2,\n        s3,\n        dx,\n        o,\n        o0,\n        y0 = [];\n    y0[0] = o = o0 = 0;\n    for (j = 1; j < m; ++j) {\n      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n        }\n        s2 += s3 * data[i][j][1];\n      }\n      y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n      if (o < o0) o0 = o;\n    }\n    for (j = 0; j < m; ++j) y0[j] -= o0;\n    return y0;\n  },\n\n  \"expand\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        k = 1 / n,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;\n      else for (i = 0; i < n; i++) data[i][j][1] = k;\n    }\n    for (j = 0; j < m; ++j) y0[j] = 0;\n    return y0;\n  },\n\n  \"zero\": d3_layout_stackOffsetZero\n\n});\n\nfunction d3_layout_stackOrderDefault(data) {\n  return d3.range(data.length);\n}\n\nfunction d3_layout_stackOffsetZero(data) {\n  var j = -1,\n      m = data[0].length,\n      y0 = [];\n  while (++j < m) y0[j] = 0;\n  return y0;\n}\n\nfunction d3_layout_stackMaxIndex(array) {\n  var i = 1,\n      j = 0,\n      v = array[0][1],\n      k,\n      n = array.length;\n  for (; i < n; ++i) {\n    if ((k = array[i][1]) > v) {\n      j = i;\n      v = k;\n    }\n  }\n  return j;\n}\n\nfunction d3_layout_stackReduceSum(d) {\n  return d.reduce(d3_layout_stackSum, 0);\n}\n\nfunction d3_layout_stackSum(p, d) {\n  return p + d[1];\n}\nd3.layout.histogram = function() {\n  var frequency = true,\n      valuer = Number,\n      ranger = d3_layout_histogramRange,\n      binner = d3_layout_histogramBinSturges;\n\n  function histogram(data, i) {\n    var bins = [],\n        values = data.map(valuer, this),\n        range = ranger.call(this, values, i),\n        thresholds = binner.call(this, range, values, i),\n        bin,\n        i = -1,\n        n = values.length,\n        m = thresholds.length - 1,\n        k = frequency ? 1 : 1 / n,\n        x;\n\n    // Initialize the bins.\n    while (++i < m) {\n      bin = bins[i] = [];\n      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n      bin.y = 0;\n    }\n\n    // Fill the bins, ignoring values outside the range.\n    i = -1; while(++i < n) {\n      x = values[i];\n      if ((x >= range[0]) && (x <= range[1])) {\n        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n        bin.y += k;\n        bin.push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  // Specifies how to extract a value from the associated data. The default\n  // value function is `Number`, which is equivalent to the identity function.\n  histogram.value = function(x) {\n    if (!arguments.length) return valuer;\n    valuer = x;\n    return histogram;\n  };\n\n  // Specifies the range of the histogram. Values outside the specified range\n  // will be ignored. The argument `x` may be specified either as a two-element\n  // array representing the minimum and maximum value of the range, or as a\n  // function that returns the range given the array of values and the current\n  // index `i`. The default range is the extent (minimum and maximum) of the\n  // values.\n  histogram.range = function(x) {\n    if (!arguments.length) return ranger;\n    ranger = d3.functor(x);\n    return histogram;\n  };\n\n  // Specifies how to bin values in the histogram. The argument `x` may be\n  // specified as a number, in which case the range of values will be split\n  // uniformly into the given number of bins. Or, `x` may be an array of\n  // threshold values, defining the bins; the specified array must contain the\n  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`\n  // may be a function which is evaluated, being passed the range, the array of\n  // values, and the current index `i`, returning an array of thresholds. The\n  // default bin function will divide the values into uniform bins using\n  // Sturges' formula.\n  histogram.bins = function(x) {\n    if (!arguments.length) return binner;\n    binner = typeof x === \"number\"\n        ? function(range) { return d3_layout_histogramBinFixed(range, x); }\n        : d3.functor(x);\n    return histogram;\n  };\n\n  // Specifies whether the histogram's `y` value is a count (frequency) or a\n  // probability (density). The default value is true.\n  histogram.frequency = function(x) {\n    if (!arguments.length) return frequency;\n    frequency = !!x;\n    return histogram;\n  };\n\n  return histogram;\n};\n\nfunction d3_layout_histogramBinSturges(range, values) {\n  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n}\n\nfunction d3_layout_histogramBinFixed(range, n) {\n  var x = -1,\n      b = +range[0],\n      m = (range[1] - b) / n,\n      f = [];\n  while (++x <= n) f[x] = m * x + b;\n  return f;\n}\n\nfunction d3_layout_histogramRange(values) {\n  return [d3.min(values), d3.max(values)];\n}\nd3.layout.hierarchy = function() {\n  var sort = d3_layout_hierarchySort,\n      children = d3_layout_hierarchyChildren,\n      value = d3_layout_hierarchyValue;\n\n  // Recursively compute the node depth and value.\n  // Also converts the data representation into a standard hierarchy structure.\n  function recurse(data, depth, nodes) {\n    var childs = children.call(hierarchy, data, depth),\n        node = d3_layout_hierarchyInline ? data : {data: data};\n    node.depth = depth;\n    nodes.push(node);\n    if (childs && (n = childs.length)) {\n      var i = -1,\n          n,\n          c = node.children = [],\n          v = 0,\n          j = depth + 1;\n      while (++i < n) {\n        d = recurse(childs[i], j, nodes);\n        d.parent = node;\n        c.push(d);\n        v += d.value;\n      }\n      if (sort) c.sort(sort);\n      if (value) node.value = v;\n    } else if (value) {\n      node.value = +value.call(hierarchy, data, depth) || 0;\n    }\n    return node;\n  }\n\n  // Recursively re-evaluates the node value.\n  function revalue(node, depth) {\n    var children = node.children,\n        v = 0;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n,\n          j = depth + 1;\n      while (++i < n) v += revalue(children[i], j);\n    } else if (value) {\n      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;\n    }\n    if (value) node.value = v;\n    return v;\n  }\n\n  function hierarchy(d) {\n    var nodes = [];\n    recurse(d, 0, nodes);\n    return nodes;\n  }\n\n  hierarchy.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return hierarchy;\n  };\n\n  hierarchy.children = function(x) {\n    if (!arguments.length) return children;\n    children = x;\n    return hierarchy;\n  };\n\n  hierarchy.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return hierarchy;\n  };\n\n  // Re-evaluates the `value` property for the specified hierarchy.\n  hierarchy.revalue = function(root) {\n    revalue(root, 0);\n    return root;\n  };\n\n  return hierarchy;\n};\n\n// A method assignment helper for hierarchy subclasses.\nfunction d3_layout_hierarchyRebind(object, hierarchy) {\n  d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n\n  // Add an alias for links, for convenience.\n  object.links = d3_layout_hierarchyLinks;\n\n  // If the new API is used, enabling inlining.\n  object.nodes = function(d) {\n    d3_layout_hierarchyInline = true;\n    return (object.nodes = object)(d);\n  };\n\n  return object;\n}\n\nfunction d3_layout_hierarchyChildren(d) {\n  return d.children;\n}\n\nfunction d3_layout_hierarchyValue(d) {\n  return d.value;\n}\n\nfunction d3_layout_hierarchySort(a, b) {\n  return b.value - a.value;\n}\n\n// Returns an array source+target objects for the specified nodes.\nfunction d3_layout_hierarchyLinks(nodes) {\n  return d3.merge(nodes.map(function(parent) {\n    return (parent.children || []).map(function(child) {\n      return {source: parent, target: child};\n    });\n  }));\n}\n\n// For backwards-compatibility, don't enable inlining by default.\nvar d3_layout_hierarchyInline = false;\nd3.layout.pack = function() {\n  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n      size = [1, 1];\n\n  function pack(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    // Recursively compute the layout.\n    root.x = 0;\n    root.y = 0;\n    d3_layout_packTree(root);\n\n    // Scale the layout to fit the requested size.\n    var w = size[0],\n        h = size[1],\n        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);\n    d3_layout_packTransform(root, w / 2, h / 2, k);\n\n    return nodes;\n  }\n\n  pack.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return pack;\n  };\n\n  return d3_layout_hierarchyRebind(pack, hierarchy);\n};\n\nfunction d3_layout_packSort(a, b) {\n  return a.value - b.value;\n}\n\nfunction d3_layout_packInsert(a, b) {\n  var c = a._pack_next;\n  a._pack_next = b;\n  b._pack_prev = a;\n  b._pack_next = c;\n  c._pack_prev = b;\n}\n\nfunction d3_layout_packSplice(a, b) {\n  a._pack_next = b;\n  b._pack_prev = a;\n}\n\nfunction d3_layout_packIntersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return dr * dr - dx * dx - dy * dy > .001; // within epsilon\n}\n\nfunction d3_layout_packCircle(nodes) {\n  var xMin = Infinity,\n      xMax = -Infinity,\n      yMin = Infinity,\n      yMax = -Infinity,\n      n = nodes.length,\n      a, b, c, j, k;\n\n  function bound(node) {\n    xMin = Math.min(node.x - node.r, xMin);\n    xMax = Math.max(node.x + node.r, xMax);\n    yMin = Math.min(node.y - node.r, yMin);\n    yMax = Math.max(node.y + node.r, yMax);\n  }\n\n  // Create node links.\n  nodes.forEach(d3_layout_packLink);\n\n  // Create first node.\n  a = nodes[0];\n  a.x = -a.r;\n  a.y = 0;\n  bound(a);\n\n  // Create second node.\n  if (n > 1) {\n    b = nodes[1];\n    b.x = b.r;\n    b.y = 0;\n    bound(b);\n\n    // Create third node and build chain.\n    if (n > 2) {\n      c = nodes[2];\n      d3_layout_packPlace(a, b, c);\n      bound(c);\n      d3_layout_packInsert(a, c);\n      a._pack_prev = c;\n      d3_layout_packInsert(c, b);\n      b = a._pack_next;\n\n      // Now iterate through the rest.\n      for (var i = 3; i < n; i++) {\n        d3_layout_packPlace(a, b, c = nodes[i]);\n\n        // Search for the closest intersection.\n        var isect = 0, s1 = 1, s2 = 1;\n        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n          if (d3_layout_packIntersects(j, c)) {\n            isect = 1;\n            break;\n          }\n        }\n        if (isect == 1) {\n          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n            if (d3_layout_packIntersects(k, c)) {\n              break;\n            }\n          }\n        }\n\n        // Update node chain.\n        if (isect) {\n          if (s1 < s2 || (s1 == s2 && b.r < a.r)) d3_layout_packSplice(a, b = j);\n          else d3_layout_packSplice(a = k, b);\n          i--;\n        } else {\n          d3_layout_packInsert(a, c);\n          b = c;\n          bound(c);\n        }\n      }\n    }\n  }\n\n  // Re-center the circles and return the encompassing radius.\n  var cx = (xMin + xMax) / 2,\n      cy = (yMin + yMax) / 2,\n      cr = 0;\n  for (var i = 0; i < n; i++) {\n    var node = nodes[i];\n    node.x -= cx;\n    node.y -= cy;\n    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));\n  }\n\n  // Remove node links.\n  nodes.forEach(d3_layout_packUnlink);\n\n  return cr;\n}\n\nfunction d3_layout_packLink(node) {\n  node._pack_next = node._pack_prev = node;\n}\n\nfunction d3_layout_packUnlink(node) {\n  delete node._pack_next;\n  delete node._pack_prev;\n}\n\nfunction d3_layout_packTree(node) {\n  var children = node.children;\n  if (children && children.length) {\n    children.forEach(d3_layout_packTree);\n    node.r = d3_layout_packCircle(children);\n  } else {\n    node.r = Math.sqrt(node.value);\n  }\n}\n\nfunction d3_layout_packTransform(node, x, y, k) {\n  var children = node.children;\n  node.x = (x += k * node.x);\n  node.y = (y += k * node.y);\n  node.r *= k;\n  if (children) {\n    var i = -1, n = children.length;\n    while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n  }\n}\n\nfunction d3_layout_packPlace(a, b, c) {\n  var db = a.r + c.r,\n      dx = b.x - a.x,\n      dy = b.y - a.y;\n  if (db && (dx || dy)) {\n    var da = b.r + c.r,\n        dc = Math.sqrt(dx * dx + dy * dy),\n        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),\n        theta = Math.acos(cos),\n        x = cos * (db /= dc),\n        y = Math.sin(theta) * db;\n    c.x = a.x + x * dx + y * dy;\n    c.y = a.y + x * dy - y * dx;\n  } else {\n    c.x = a.x + db;\n    c.y = a.y;\n  }\n}\n// Implements a hierarchical layout using the cluster (or dendrogram)\n// algorithm.\nd3.layout.cluster = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function cluster(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0],\n        previousNode,\n        x = 0,\n        kx,\n        ky;\n\n    // First walk, computing the initial x & y values.\n    d3_layout_treeVisitAfter(root, function(node) {\n      var children = node.children;\n      if (children && children.length) {\n        node.x = d3_layout_clusterX(children);\n        node.y = d3_layout_clusterY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_clusterLeft(root),\n        right = d3_layout_clusterRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n    });\n\n    return nodes;\n  }\n\n  cluster.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return cluster;\n  };\n\n  cluster.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return cluster;\n  };\n\n  return d3_layout_hierarchyRebind(cluster, hierarchy);\n};\n\nfunction d3_layout_clusterY(children) {\n  return 1 + d3.max(children, function(child) {\n    return child.y;\n  });\n}\n\nfunction d3_layout_clusterX(children) {\n  return children.reduce(function(x, child) {\n    return x + child.x;\n  }, 0) / children.length;\n}\n\nfunction d3_layout_clusterLeft(node) {\n  var children = node.children;\n  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n}\n\nfunction d3_layout_clusterRight(node) {\n  var children = node.children, n;\n  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n}\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nd3.layout.tree = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function tree(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    function firstWalk(node, previousSibling) {\n      var children = node.children,\n          layout = node._tree;\n      if (children && (n = children.length)) {\n        var n,\n            firstChild = children[0],\n            previousChild,\n            ancestor = firstChild,\n            child,\n            i = -1;\n        while (++i < n) {\n          child = children[i];\n          firstWalk(child, previousChild);\n          ancestor = apportion(child, previousChild, ancestor);\n          previousChild = child;\n        }\n        d3_layout_treeShift(node);\n        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n          layout.mod = layout.prelim - midpoint;\n        } else {\n          layout.prelim = midpoint;\n        }\n      } else {\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n        }\n      }\n    }\n\n    function secondWalk(node, x) {\n      node.x = node._tree.prelim + x;\n      var children = node.children;\n      if (children && (n = children.length)) {\n        var i = -1,\n            n;\n        x += node._tree.mod;\n        while (++i < n) {\n          secondWalk(children[i], x);\n        }\n      }\n    }\n\n    function apportion(node, previousSibling, ancestor) {\n      if (previousSibling) {\n        var vip = node,\n            vop = node,\n            vim = previousSibling,\n            vom = node.parent.children[0],\n            sip = vip._tree.mod,\n            sop = vop._tree.mod,\n            sim = vim._tree.mod,\n            som = vom._tree.mod,\n            shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop._tree.ancestor = node;\n          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim._tree.mod;\n          sip += vip._tree.mod;\n          som += vom._tree.mod;\n          sop += vop._tree.mod;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop._tree.thread = vim;\n          vop._tree.mod += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom._tree.thread = vip;\n          vom._tree.mod += sip - som;\n          ancestor = node;\n        }\n      }\n      return ancestor;\n    }\n\n    // Initialize temporary layout variables.\n    d3_layout_treeVisitAfter(root, function(node, previousSibling) {\n      node._tree = {\n        ancestor: node,\n        prelim: 0,\n        mod: 0,\n        change: 0,\n        shift: 0,\n        number: previousSibling ? previousSibling._tree.number + 1 : 0\n      };\n    });\n\n    // Compute the layout using Buchheim et al.'s algorithm.\n    firstWalk(root);\n    secondWalk(root, -root._tree.prelim);\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\n        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\n        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2,\n        y1 = deep.depth || 1;\n\n    // Clear temporary layout variables; transform x and y.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = node.depth / y1 * size[1];\n      delete node._tree;\n    });\n\n    return nodes;\n  }\n\n  tree.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return tree;\n  };\n\n  tree.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return tree;\n  };\n\n  return d3_layout_hierarchyRebind(tree, hierarchy);\n};\n\nfunction d3_layout_treeSeparation(a, b) {\n  return a.parent == b.parent ? 1 : 2;\n}\n\n// function d3_layout_treeSeparationRadial(a, b) {\n//   return (a.parent == b.parent ? 1 : 2) / a.depth;\n// }\n\nfunction d3_layout_treeLeft(node) {\n  var children = node.children;\n  return children && children.length ? children[0] : node._tree.thread;\n}\n\nfunction d3_layout_treeRight(node) {\n  var children = node.children,\n      n;\n  return children && (n = children.length) ? children[n - 1] : node._tree.thread;\n}\n\nfunction d3_layout_treeSearch(node, compare) {\n  var children = node.children;\n  if (children && (n = children.length)) {\n    var child,\n        n,\n        i = -1;\n    while (++i < n) {\n      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\n        node = child;\n      }\n    }\n  }\n  return node;\n}\n\nfunction d3_layout_treeRightmost(a, b) {\n  return a.x - b.x;\n}\n\nfunction d3_layout_treeLeftmost(a, b) {\n  return b.x - a.x;\n}\n\nfunction d3_layout_treeDeepest(a, b) {\n  return a.depth - b.depth;\n}\n\nfunction d3_layout_treeVisitAfter(node, callback) {\n  function visit(node, previousSibling) {\n    var children = node.children;\n    if (children && (n = children.length)) {\n      var child,\n          previousChild = null,\n          i = -1,\n          n;\n      while (++i < n) {\n        child = children[i];\n        visit(child, previousChild);\n        previousChild = child;\n      }\n    }\n    callback(node, previousSibling);\n  }\n  visit(node, null);\n}\n\nfunction d3_layout_treeShift(node) {\n  var shift = 0,\n      change = 0,\n      children = node.children,\n      i = children.length,\n      child;\n  while (--i >= 0) {\n    child = children[i]._tree;\n    child.prelim += shift;\n    child.mod += shift;\n    shift += child.shift + (change += child.change);\n  }\n}\n\nfunction d3_layout_treeMove(ancestor, node, shift) {\n  ancestor = ancestor._tree;\n  node = node._tree;\n  var change = shift / (node.number - ancestor.number);\n  ancestor.change += change;\n  node.change -= change;\n  node.shift += shift;\n  node.prelim += shift;\n  node.mod += shift;\n}\n\nfunction d3_layout_treeAncestor(vim, node, ancestor) {\n  return vim._tree.ancestor.parent == node.parent\n      ? vim._tree.ancestor\n      : ancestor;\n}\n// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n// Modified to support a target aspect ratio by Jeff Heer\nd3.layout.treemap = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      round = Math.round,\n      size = [1, 1], // width, height\n      padding = null,\n      pad = d3_layout_treemapPadNull,\n      sticky = false,\n      stickies,\n      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio\n\n  // Compute the area for each child based on value & scale.\n  function scale(children, k) {\n    var i = -1,\n        n = children.length,\n        child,\n        area;\n    while (++i < n) {\n      area = (child = children[i]).value * (k < 0 ? 0 : k);\n      child.area = isNaN(area) || area <= 0 ? 0 : area;\n    }\n  }\n\n  // Recursively arranges the specified node's children into squarified rows.\n  function squarify(node) {\n    var children = node.children;\n    if (children && children.length) {\n      var rect = pad(node),\n          row = [],\n          remaining = children.slice(), // copy-on-write\n          child,\n          best = Infinity, // the best row score so far\n          score, // the current row score\n          u = Math.min(rect.dx, rect.dy), // initial orientation\n          n;\n      scale(remaining, rect.dx * rect.dy / node.value);\n      row.area = 0;\n      while ((n = remaining.length) > 0) {\n        row.push(child = remaining[n - 1]);\n        row.area += child.area;\n        if ((score = worst(row, u)) <= best) { // continue with this orientation\n          remaining.pop();\n          best = score;\n        } else { // abort, and try a different orientation\n          row.area -= row.pop().area;\n          position(row, u, rect, false);\n          u = Math.min(rect.dx, rect.dy);\n          row.length = row.area = 0;\n          best = Infinity;\n        }\n      }\n      if (row.length) {\n        position(row, u, rect, true);\n        row.length = row.area = 0;\n      }\n      children.forEach(squarify);\n    }\n  }\n\n  // Recursively resizes the specified node's children into existing rows.\n  // Preserves the existing layout!\n  function stickify(node) {\n    var children = node.children;\n    if (children && children.length) {\n      var rect = pad(node),\n          remaining = children.slice(), // copy-on-write\n          child,\n          row = [];\n      scale(remaining, rect.dx * rect.dy / node.value);\n      row.area = 0;\n      while (child = remaining.pop()) {\n        row.push(child);\n        row.area += child.area;\n        if (child.z != null) {\n          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n          row.length = row.area = 0;\n        }\n      }\n      children.forEach(stickify);\n    }\n  }\n\n  // Computes the score for the specified row, as the worst aspect ratio.\n  function worst(row, u) {\n    var s = row.area,\n        r,\n        rmax = 0,\n        rmin = Infinity,\n        i = -1,\n        n = row.length;\n    while (++i < n) {\n      if (!(r = row[i].area)) continue;\n      if (r < rmin) rmin = r;\n      if (r > rmax) rmax = r;\n    }\n    s *= s;\n    u *= u;\n    return s\n        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))\n        : Infinity;\n  }\n\n  // Positions the specified row of nodes. Modifies `rect`.\n  function position(row, u, rect, flush) {\n    var i = -1,\n        n = row.length,\n        x = rect.x,\n        y = rect.y,\n        v = u ? round(row.area / u) : 0,\n        o;\n    if (u == rect.dx) { // horizontal subdivision\n      if (flush || v > rect.dy) v = rect.dy; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dy = v;\n        x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n      }\n      o.z = true;\n      o.dx += rect.x + rect.dx - x; // rounding error\n      rect.y += v;\n      rect.dy -= v;\n    } else { // vertical subdivision\n      if (flush || v > rect.dx) v = rect.dx; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dx = v;\n        y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n      }\n      o.z = false;\n      o.dy += rect.y + rect.dy - y; // rounding error\n      rect.x += v;\n      rect.dx -= v;\n    }\n  }\n\n  function treemap(d) {\n    var nodes = stickies || hierarchy(d),\n        root = nodes[0];\n    root.x = 0;\n    root.y = 0;\n    root.dx = size[0];\n    root.dy = size[1];\n    if (stickies) hierarchy.revalue(root);\n    scale([root], root.dx * root.dy / root.value);\n    (stickies ? stickify : squarify)(root);\n    if (sticky) stickies = nodes;\n    return nodes;\n  }\n\n  treemap.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return treemap;\n  };\n\n  treemap.padding = function(x) {\n    if (!arguments.length) return padding;\n\n    function padFunction(node) {\n      var p = x.call(treemap, node, node.depth);\n      return p == null\n          ? d3_layout_treemapPadNull(node)\n          : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\n    }\n\n    function padConstant(node) {\n      return d3_layout_treemapPad(node, x);\n    }\n\n    var type;\n    pad = (padding = x) == null ? d3_layout_treemapPadNull\n        : (type = typeof x) === \"function\" ? padFunction\n        : type === \"number\" ? (x = [x, x, x, x], padConstant)\n        : padConstant;\n    return treemap;\n  };\n\n  treemap.round = function(x) {\n    if (!arguments.length) return round != Number;\n    round = x ? Math.round : Number;\n    return treemap;\n  };\n\n  treemap.sticky = function(x) {\n    if (!arguments.length) return sticky;\n    sticky = x;\n    stickies = null;\n    return treemap;\n  };\n\n  treemap.ratio = function(x) {\n    if (!arguments.length) return ratio;\n    ratio = x;\n    return treemap;\n  };\n\n  return d3_layout_hierarchyRebind(treemap, hierarchy);\n};\n\nfunction d3_layout_treemapPadNull(node) {\n  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};\n}\n\nfunction d3_layout_treemapPad(node, padding) {\n  var x = node.x + padding[3],\n      y = node.y + padding[0],\n      dx = node.dx - padding[1] - padding[3],\n      dy = node.dy - padding[0] - padding[2];\n  if (dx < 0) { x += dx / 2; dx = 0; }\n  if (dy < 0) { y += dy / 2; dy = 0; }\n  return {x: x, y: y, dx: dx, dy: dy};\n}\nd3.csv = function(url, callback) {\n  d3.text(url, \"text/csv\", function(text) {\n    callback(text && d3.csv.parse(text));\n  });\n};\nd3.csv.parse = function(text) {\n  var header;\n  return d3.csv.parseRows(text, function(row, i) {\n    if (i) {\n      var o = {}, j = -1, m = header.length;\n      while (++j < m) o[header[j]] = row[j];\n      return o;\n    } else {\n      header = row;\n      return null;\n    }\n  });\n};\n\nd3.csv.parseRows = function(text, f) {\n  var EOL = {}, // sentinel value for end-of-line\n      EOF = {}, // sentinel value for end-of-file\n      rows = [], // output rows\n      re = /\\r\\n|[,\\r\\n]/g, // field separator regex\n      n = 0, // the current line number\n      t, // the current token\n      eol; // is the current token followed by EOL?\n\n  re.lastIndex = 0; // work-around bug in FF 3.6\n\n  /** @private Returns the next token. */\n  function token() {\n    if (re.lastIndex >= text.length) return EOF; // special case: end of file\n    if (eol) { eol = false; return EOL; } // special case: end of line\n\n    // special case: quotes\n    var j = re.lastIndex;\n    if (text.charCodeAt(j) === 34) {\n      var i = j;\n      while (i++ < text.length) {\n        if (text.charCodeAt(i) === 34) {\n          if (text.charCodeAt(i + 1) !== 34) break;\n          i++;\n        }\n      }\n      re.lastIndex = i + 2;\n      var c = text.charCodeAt(i + 1);\n      if (c === 13) {\n        eol = true;\n        if (text.charCodeAt(i + 2) === 10) re.lastIndex++;\n      } else if (c === 10) {\n        eol = true;\n      }\n      return text.substring(j + 1, i).replace(/\"\"/g, \"\\\"\");\n    }\n\n    // common case\n    var m = re.exec(text);\n    if (m) {\n      eol = m[0].charCodeAt(0) !== 44;\n      return text.substring(j, m.index);\n    }\n    re.lastIndex = text.length;\n    return text.substring(j);\n  }\n\n  while ((t = token()) !== EOF) {\n    var a = [];\n    while ((t !== EOL) && (t !== EOF)) {\n      a.push(t);\n      t = token();\n    }\n    if (f && !(a = f(a, n++))) continue;\n    rows.push(a);\n  }\n\n  return rows;\n};\nd3.csv.format = function(rows) {\n  return rows.map(d3_csv_formatRow).join(\"\\n\");\n};\n\nfunction d3_csv_formatRow(row) {\n  return row.map(d3_csv_formatValue).join(\",\");\n}\n\nfunction d3_csv_formatValue(text) {\n  return /[\",\\n]/.test(text)\n      ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n      : text;\n}\nd3.geo = {};\n\nvar d3_geo_radians = Math.PI / 180;\n// TODO clip input coordinates on opposite hemisphere\nd3.geo.azimuthal = function() {\n  var mode = \"orthographic\", // or stereographic, gnomonic, equidistant or equalarea\n      origin,\n      scale = 200,\n      translate = [480, 250],\n      x0,\n      y0,\n      cy0,\n      sy0;\n\n  function azimuthal(coordinates) {\n    var x1 = coordinates[0] * d3_geo_radians - x0,\n        y1 = coordinates[1] * d3_geo_radians,\n        cx1 = Math.cos(x1),\n        sx1 = Math.sin(x1),\n        cy1 = Math.cos(y1),\n        sy1 = Math.sin(y1),\n        cc = mode !== \"orthographic\" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,\n        c,\n        k = mode === \"stereographic\" ? 1 / (1 + cc)\n          : mode === \"gnomonic\" ? 1 / cc\n          : mode === \"equidistant\" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0)\n          : mode === \"equalarea\" ? Math.sqrt(2 / (1 + cc))\n          : 1,\n        x = k * cy1 * sx1,\n        y = k * (sy0 * cy1 * cx1 - cy0 * sy1);\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  azimuthal.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale,\n        p = Math.sqrt(x * x + y * y),\n        c = mode === \"stereographic\" ? 2 * Math.atan(p)\n          : mode === \"gnomonic\" ? Math.atan(p)\n          : mode === \"equidistant\" ? p\n          : mode === \"equalarea\" ? 2 * Math.asin(.5 * p)\n          : Math.asin(p),\n        sc = Math.sin(c),\n        cc = Math.cos(c);\n    return [\n      (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians,\n      Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians\n    ];\n  };\n\n  azimuthal.mode = function(x) {\n    if (!arguments.length) return mode;\n    mode = x + \"\";\n    return azimuthal;\n  };\n\n  azimuthal.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    x0 = origin[0] * d3_geo_radians;\n    y0 = origin[1] * d3_geo_radians;\n    cy0 = Math.cos(y0);\n    sy0 = Math.sin(y0);\n    return azimuthal;\n  };\n\n  azimuthal.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return azimuthal;\n  };\n\n  azimuthal.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return azimuthal;\n  };\n\n  return azimuthal.origin([0, 0]);\n};\n// Derived from Tom Carden's Albers implementation for Protovis.\n// http://gist.github.com/476238\n// http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\n\nd3.geo.albers = function() {\n  var origin = [-98, 38],\n      parallels = [29.5, 45.5],\n      scale = 1000,\n      translate = [480, 250],\n      lng0, // d3_geo_radians * origin[0]\n      n,\n      C,\n      p0;\n\n  function albers(coordinates) {\n    var t = n * (d3_geo_radians * coordinates[0] - lng0),\n        p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;\n    return [\n      scale * p * Math.sin(t) + translate[0],\n      scale * (p * Math.cos(t) - p0) + translate[1]\n    ];\n  }\n\n  albers.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale,\n        p0y = p0 + y,\n        t = Math.atan2(x, p0y),\n        p = Math.sqrt(x * x + p0y * p0y);\n    return [\n      (lng0 + t / n) / d3_geo_radians,\n      Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians\n    ];\n  };\n\n  function reload() {\n    var phi1 = d3_geo_radians * parallels[0],\n        phi2 = d3_geo_radians * parallels[1],\n        lat0 = d3_geo_radians * origin[1],\n        s = Math.sin(phi1),\n        c = Math.cos(phi1);\n    lng0 = d3_geo_radians * origin[0];\n    n = .5 * (s + Math.sin(phi2));\n    C = c * c + 2 * n * s;\n    p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;\n    return albers;\n  }\n\n  albers.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = [+x[0], +x[1]];\n    return reload();\n  };\n\n  albers.parallels = function(x) {\n    if (!arguments.length) return parallels;\n    parallels = [+x[0], +x[1]];\n    return reload();\n  };\n\n  albers.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return albers;\n  };\n\n  albers.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return albers;\n  };\n\n  return reload();\n};\n\n// A composite projection for the United States, 960x500. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n// TODO allow the composite projection to be rescaled?\nd3.geo.albersUsa = function() {\n  var lower48 = d3.geo.albers();\n\n  var alaska = d3.geo.albers()\n      .origin([-160, 60])\n      .parallels([55, 65]);\n\n  var hawaii = d3.geo.albers()\n      .origin([-160, 20])\n      .parallels([8, 18]);\n\n  var puertoRico = d3.geo.albers()\n      .origin([-60, 10])\n      .parallels([8, 18]);\n\n  function albersUsa(coordinates) {\n    var lon = coordinates[0],\n        lat = coordinates[1];\n    return (lat > 50 ? alaska\n        : lon < -140 ? hawaii\n        : lat < 21 ? puertoRico\n        : lower48)(coordinates);\n  }\n\n  albersUsa.scale = function(x) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(x);\n    alaska.scale(x * .6);\n    hawaii.scale(x);\n    puertoRico.scale(x * 1.5);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(x) {\n    if (!arguments.length) return lower48.translate();\n    var dz = lower48.scale() / 1000,\n        dx = x[0],\n        dy = x[1];\n    lower48.translate(x);\n    alaska.translate([dx - 400 * dz, dy + 170 * dz]);\n    hawaii.translate([dx - 190 * dz, dy + 200 * dz]);\n    puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);\n    return albersUsa;\n  };\n\n  return albersUsa.scale(lower48.scale());\n};\nd3.geo.bonne = function() {\n  var scale = 200,\n      translate = [480, 250],\n      x0, // origin longitude in radians\n      y0, // origin latitude in radians\n      y1, // parallel latitude in radians\n      c1; // cot(y1)\n\n  function bonne(coordinates) {\n    var x = coordinates[0] * d3_geo_radians - x0,\n        y = coordinates[1] * d3_geo_radians - y0;\n    if (y1) {\n      var p = c1 + y1 - y, E = x * Math.cos(y) / p;\n      x = p * Math.sin(E);\n      y = p * Math.cos(E) - c1;\n    } else {\n      x *= Math.cos(y);\n      y *= -1;\n    }\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  bonne.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    if (y1) {\n      var c = c1 + y, p = Math.sqrt(x * x + c * c);\n      y = c1 + y1 - p;\n      x = x0 + p * Math.atan2(x, c) / Math.cos(y);\n    } else {\n      y *= -1;\n      x /= Math.cos(y);\n    }\n    return [\n      x / d3_geo_radians,\n      y / d3_geo_radians\n    ];\n  };\n\n  // 90 for Werner, 0 for Sinusoidal\n  bonne.parallel = function(x) {\n    if (!arguments.length) return y1 / d3_geo_radians;\n    c1 = 1 / Math.tan(y1 = x * d3_geo_radians);\n    return bonne;\n  };\n\n  bonne.origin = function(x) {\n    if (!arguments.length) return [x0 / d3_geo_radians, y0 / d3_geo_radians];\n    x0 = x[0] * d3_geo_radians;\n    y0 = x[1] * d3_geo_radians;\n    return bonne;\n  };\n\n  bonne.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return bonne;\n  };\n\n  bonne.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return bonne;\n  };\n\n  return bonne.origin([0, 0]).parallel(45);\n};\nd3.geo.equirectangular = function() {\n  var scale = 500,\n      translate = [480, 250];\n\n  function equirectangular(coordinates) {\n    var x = coordinates[0] / 360,\n        y = -coordinates[1] / 360;\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  equirectangular.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    return [\n      360 * x,\n      -360 * y\n    ];\n  };\n\n  equirectangular.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return equirectangular;\n  };\n\n  equirectangular.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return equirectangular;\n  };\n\n  return equirectangular;\n};\nd3.geo.mercator = function() {\n  var scale = 500,\n      translate = [480, 250];\n\n  function mercator(coordinates) {\n    var x = coordinates[0] / 360,\n        y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;\n    return [\n      scale * x + translate[0],\n      scale * Math.max(-.5, Math.min(.5, y)) + translate[1]\n    ];\n  }\n\n  mercator.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    return [\n      360 * x,\n      2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90\n    ];\n  };\n\n  mercator.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return mercator;\n  };\n\n  mercator.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return mercator;\n  };\n\n  return mercator;\n};\nfunction d3_geo_type(types, defaultValue) {\n  return function(object) {\n    return object && types.hasOwnProperty(object.type) ? types[object.type](object) : defaultValue;\n  };\n}\n/**\n * Returns a function that, given a GeoJSON object (e.g., a feature), returns\n * the corresponding SVG path. The function can be customized by overriding the\n * projection. Point features are mapped to circles with a default radius of\n * 4.5px; the radius can be specified either as a constant or a function that\n * is evaluated per object.\n */\nd3.geo.path = function() {\n  var pointRadius = 4.5,\n      pointCircle = d3_path_circle(pointRadius),\n      projection = d3.geo.albersUsa();\n\n  function path(d, i) {\n    if (typeof pointRadius === \"function\") {\n      pointCircle = d3_path_circle(pointRadius.apply(this, arguments));\n    }\n    return pathType(d) || null;\n  }\n\n  function project(coordinates) {\n    return projection(coordinates).join(\",\");\n  }\n\n  var pathType = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var path = [],\n          features = o.features,\n          i = -1, // features.index\n          n = features.length;\n      while (++i < n) path.push(pathType(features[i].geometry));\n      return path.join(\"\");\n    },\n\n    Feature: function(o) {\n      return pathType(o.geometry);\n    },\n\n    Point: function(o) {\n      return \"M\" + project(o.coordinates) + pointCircle;\n    },\n\n    MultiPoint: function(o) {\n      var path = [],\n          coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length;\n      while (++i < n) path.push(\"M\", project(coordinates[i]), pointCircle);\n      return path.join(\"\");\n    },\n\n    LineString: function(o) {\n      var path = [\"M\"],\n          coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length;\n      while (++i < n) path.push(project(coordinates[i]), \"L\");\n      path.pop();\n      return path.join(\"\");\n    },\n\n    MultiLineString: function(o) {\n      var path = [],\n          coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates.index\n          m; // subcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        m = subcoordinates.length;\n        path.push(\"M\");\n        while (++j < m) path.push(project(subcoordinates[j]), \"L\");\n        path.pop();\n      }\n      return path.join(\"\");\n    },\n\n    Polygon: function(o) {\n      var path = [],\n          coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates.index\n          m; // subcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        if ((m = subcoordinates.length - 1) > 0) {\n          path.push(\"M\");\n          while (++j < m) path.push(project(subcoordinates[j]), \"L\");\n          path[path.length - 1] = \"Z\";\n        }\n      }\n      return path.join(\"\");\n    },\n\n    MultiPolygon: function(o) {\n      var path = [],\n          coordinates = o.coordinates,\n          i = -1, // coordinates index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates index\n          m, // subcoordinates.length\n          subsubcoordinates, // subcoordinates[j]\n          k, // subsubcoordinates index\n          p; // subsubcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        m = subcoordinates.length;\n        while (++j < m) {\n          subsubcoordinates = subcoordinates[j];\n          k = -1;\n          if ((p = subsubcoordinates.length - 1) > 0) {\n            path.push(\"M\");\n            while (++k < p) path.push(project(subsubcoordinates[k]), \"L\");\n            path[path.length - 1] = \"Z\";\n          }\n        }\n      }\n      return path.join(\"\");\n    },\n\n    GeometryCollection: function(o) {\n      var path = [],\n          geometries = o.geometries,\n          i = -1, // geometries index\n          n = geometries.length;\n      while (++i < n) path.push(pathType(geometries[i]));\n      return path.join(\"\");\n    }\n\n  });\n\n  var areaType = path.area = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var area = 0,\n          features = o.features,\n          i = -1, // features.index\n          n = features.length;\n      while (++i < n) area += areaType(features[i]);\n      return area;\n    },\n\n    Feature: function(o) {\n      return areaType(o.geometry);\n    },\n\n    Polygon: function(o) {\n      return polygonArea(o.coordinates);\n    },\n\n    MultiPolygon: function(o) {\n      var sum = 0,\n          coordinates = o.coordinates,\n          i = -1, // coordinates index\n          n = coordinates.length;\n      while (++i < n) sum += polygonArea(coordinates[i]);\n      return sum;\n    },\n\n    GeometryCollection: function(o) {\n      var sum = 0,\n          geometries = o.geometries,\n          i = -1, // geometries index\n          n = geometries.length;\n      while (++i < n) sum += areaType(geometries[i]);\n      return sum;\n    }\n\n  }, 0);\n\n  function polygonArea(coordinates) {\n    var sum = area(coordinates[0]), // exterior ring\n        i = 0, // coordinates.index\n        n = coordinates.length;\n    while (++i < n) sum -= area(coordinates[i]); // holes\n    return sum;\n  }\n\n  function polygonCentroid(coordinates) {\n    var polygon = d3.geom.polygon(coordinates[0].map(projection)), // exterior ring\n        area = polygon.area(),\n        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1),\n        x = centroid[0],\n        y = centroid[1],\n        z = area,\n        i = 0, // coordinates index\n        n = coordinates.length;\n    while (++i < n) {\n      polygon = d3.geom.polygon(coordinates[i].map(projection)); // holes\n      area = polygon.area();\n      centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);\n      x -= centroid[0];\n      y -= centroid[1];\n      z -= area;\n    }\n    return [x, y, 6 * z]; // weighted centroid\n  }\n\n  var centroidType = path.centroid = d3_geo_type({\n\n    // TODO FeatureCollection\n    // TODO Point\n    // TODO MultiPoint\n    // TODO LineString\n    // TODO MultiLineString\n    // TODO GeometryCollection\n\n    Feature: function(o) {\n      return centroidType(o.geometry);\n    },\n\n    Polygon: function(o) {\n      var centroid = polygonCentroid(o.coordinates);\n      return [centroid[0] / centroid[2], centroid[1] / centroid[2]];\n    },\n\n    MultiPolygon: function(o) {\n      var area = 0,\n          coordinates = o.coordinates,\n          centroid,\n          x = 0,\n          y = 0,\n          z = 0,\n          i = -1, // coordinates index\n          n = coordinates.length;\n      while (++i < n) {\n        centroid = polygonCentroid(coordinates[i]);\n        x += centroid[0];\n        y += centroid[1];\n        z += centroid[2];\n      }\n      return [x / z, y / z];\n    }\n\n  });\n\n  function area(coordinates) {\n    return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());\n  }\n\n  path.projection = function(x) {\n    projection = x;\n    return path;\n  };\n\n  path.pointRadius = function(x) {\n    if (typeof x === \"function\") pointRadius = x;\n    else {\n      pointRadius = +x;\n      pointCircle = d3_path_circle(pointRadius);\n    }\n    return path;\n  };\n\n  return path;\n};\n\nfunction d3_path_circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + (-2 * radius)\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + (+2 * radius)\n      + \"z\";\n}\n/**\n * Given a GeoJSON object, returns the corresponding bounding box. The bounding\n * box is represented by a two-dimensional array: [[left, bottom], [right,\n * top]], where left is the minimum longitude, bottom is the minimum latitude,\n * right is maximum longitude, and top is the maximum latitude.\n */\nd3.geo.bounds = function(feature) {\n  var left = Infinity,\n      bottom = Infinity,\n      right = -Infinity,\n      top = -Infinity;\n  d3_geo_bounds(feature, function(x, y) {\n    if (x < left) left = x;\n    if (x > right) right = x;\n    if (y < bottom) bottom = y;\n    if (y > top) top = y;\n  });\n  return [[left, bottom], [right, top]];\n};\n\nfunction d3_geo_bounds(o, f) {\n  if (d3_geo_boundsTypes.hasOwnProperty(o.type)) d3_geo_boundsTypes[o.type](o, f);\n}\n\nvar d3_geo_boundsTypes = {\n  Feature: d3_geo_boundsFeature,\n  FeatureCollection: d3_geo_boundsFeatureCollection,\n  GeometryCollection: d3_geo_boundsGeometryCollection,\n  LineString: d3_geo_boundsLineString,\n  MultiLineString: d3_geo_boundsMultiLineString,\n  MultiPoint: d3_geo_boundsLineString,\n  MultiPolygon: d3_geo_boundsMultiPolygon,\n  Point: d3_geo_boundsPoint,\n  Polygon: d3_geo_boundsPolygon\n};\n\nfunction d3_geo_boundsFeature(o, f) {\n  d3_geo_bounds(o.geometry, f);\n}\n\nfunction d3_geo_boundsFeatureCollection(o, f) {\n  for (var a = o.features, i = 0, n = a.length; i < n; i++) {\n    d3_geo_bounds(a[i].geometry, f);\n  }\n}\n\nfunction d3_geo_boundsGeometryCollection(o, f) {\n  for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {\n    d3_geo_bounds(a[i], f);\n  }\n}\n\nfunction d3_geo_boundsLineString(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    f.apply(null, a[i]);\n  }\n}\n\nfunction d3_geo_boundsMultiLineString(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    for (var b = a[i], j = 0, m = b.length; j < m; j++) {\n      f.apply(null, b[j]);\n    }\n  }\n}\n\nfunction d3_geo_boundsMultiPolygon(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {\n      f.apply(null, b[j]);\n    }\n  }\n}\n\nfunction d3_geo_boundsPoint(o, f) {\n  f.apply(null, o.coordinates);\n}\n\nfunction d3_geo_boundsPolygon(o, f) {\n  for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {\n    f.apply(null, a[i]);\n  }\n}\n// TODO breakAtDateLine?\n\nd3.geo.circle = function() {\n  var origin = [0, 0],\n      degrees = 90 - 1e-2,\n      radians = degrees * d3_geo_radians,\n      arc = d3.geo.greatArc().target(Object);\n\n  function circle() {\n    // TODO render a circle as a Polygon\n  }\n\n  function visible(point) {\n    return arc.distance(point) < radians;\n  }\n\n  circle.clip = function(d) {\n    arc.source(typeof origin === \"function\" ? origin.apply(this, arguments) : origin);\n    return clipType(d);\n  };\n\n  var clipType = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var features = o.features.map(clipType).filter(Object);\n      return features && (o = Object.create(o), o.features = features, o);\n    },\n\n    Feature: function(o) {\n      var geometry = clipType(o.geometry);\n      return geometry && (o = Object.create(o), o.geometry = geometry, o);\n    },\n\n    Point: function(o) {\n      return visible(o.coordinates) && o;\n    },\n\n    MultiPoint: function(o) {\n      var coordinates = o.coordinates.filter(visible);\n      return coordinates.length && {\n        type: o.type,\n        coordinates: coordinates\n      };\n    },\n\n    LineString: function(o) {\n      var coordinates = clip(o.coordinates);\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    MultiLineString: function(o) {\n      var coordinates = o.coordinates.map(clip).filter(function(d) { return d.length; });\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    Polygon: function(o) {\n      var coordinates = o.coordinates.map(clip);\n      return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    MultiPolygon: function(o) {\n      var coordinates = o.coordinates.map(function(d) { return d.map(clip); }).filter(function(d) { return d[0].length; });\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    GeometryCollection: function(o) {\n      var geometries = o.geometries.map(clipType).filter(Object);\n      return geometries.length && (o = Object.create(o), o.geometries = geometries, o);\n    }\n\n  });\n\n  function clip(coordinates) {\n    var i = -1,\n        n = coordinates.length,\n        clipped = [],\n        p0,\n        p1,\n        p2,\n        d0,\n        d1;\n\n    while (++i < n) {\n      d1 = arc.distance(p2 = coordinates[i]);\n      if (d1 < radians) {\n        if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));\n        clipped.push(p2);\n        p0 = p1 = null;\n      } else {\n        p1 = p2;\n        if (!p0 && clipped.length) {\n          clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));\n          p0 = p1;\n        }\n      }\n      d0 = d1;\n    }\n\n    if (p1 && clipped.length) {\n      d1 = arc.distance(p2 = clipped[0]);\n      clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));\n    }\n\n    return resample(clipped);\n  }\n\n  // Resample coordinates, creating great arcs between each.\n  function resample(coordinates) {\n    var i = 0,\n        n = coordinates.length,\n        j,\n        m,\n        resampled = n ? [coordinates[0]] : coordinates,\n        resamples,\n        origin = arc.source();\n\n    while (++i < n) {\n      resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;\n      for (j = 0, m = resamples.length; ++j < m;) resampled.push(resamples[j]);\n    }\n\n    arc.source(origin);\n    return resampled;\n  }\n\n  circle.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    return circle;\n  };\n\n  circle.angle = function(x) {\n    if (!arguments.length) return degrees;\n    radians = (degrees = +x) * d3_geo_radians;\n    return circle;\n  };\n\n  // Precision is specified in degrees.\n  circle.precision = function(x) {\n    if (!arguments.length) return arc.precision();\n    arc.precision(x);\n    return circle;\n  };\n\n  return circle;\n}\nd3.geo.greatArc = function() {\n  var source = d3_geo_greatArcSource,\n      target = d3_geo_greatArcTarget,\n      precision = 6 * d3_geo_radians;\n\n  function greatArc() {\n    var a = typeof source === \"function\" ? source.apply(this, arguments) : source,\n        b = typeof target === \"function\" ? target.apply(this, arguments) : target,\n        i = d3_geo_greatArcInterpolate(a, b),\n        dt = precision / i.d,\n        t = 0,\n        coordinates = [a];\n    while ((t += dt) < 1) coordinates.push(i(t));\n    coordinates.push(b);\n    return {\n      type: \"LineString\",\n      coordinates: coordinates\n    };\n  }\n\n  // Length returned in radians; multiply by radius for distance.\n  greatArc.distance = function() {\n    var a = typeof source === \"function\" ? source.apply(this, arguments) : source,\n        b = typeof target === \"function\" ? target.apply(this, arguments) : target;\n     return d3_geo_greatArcInterpolate(a, b).d;\n  };\n\n  greatArc.source = function(x) {\n    if (!arguments.length) return source;\n    source = x;\n    return greatArc;\n  };\n\n  greatArc.target = function(x) {\n    if (!arguments.length) return target;\n    target = x;\n    return greatArc;\n  };\n\n  // Precision is specified in degrees.\n  greatArc.precision = function(x) {\n    if (!arguments.length) return precision / d3_geo_radians;\n    precision = x * d3_geo_radians;\n    return greatArc;\n  };\n\n  return greatArc;\n};\n\nfunction d3_geo_greatArcSource(d) {\n  return d.source;\n}\n\nfunction d3_geo_greatArcTarget(d) {\n  return d.target;\n}\n\nfunction d3_geo_greatArcInterpolate(a, b) {\n  var x0 = a[0] * d3_geo_radians, cx0 = Math.cos(x0), sx0 = Math.sin(x0),\n      y0 = a[1] * d3_geo_radians, cy0 = Math.cos(y0), sy0 = Math.sin(y0),\n      x1 = b[0] * d3_geo_radians, cx1 = Math.cos(x1), sx1 = Math.sin(x1),\n      y1 = b[1] * d3_geo_radians, cy1 = Math.cos(y1), sy1 = Math.sin(y1),\n      d = interpolate.d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))),\n      sd = Math.sin(d);\n\n  // From http://williams.best.vwh.net/avform.htm#Intermediate\n  function interpolate(t) {\n    var A = Math.sin(d - (t *= d)) / sd,\n        B = Math.sin(t) / sd,\n        x = A * cy0 * cx0 + B * cy1 * cx1,\n        y = A * cy0 * sx0 + B * cy1 * sx1,\n        z = A * sy0       + B * sy1;\n    return [\n      Math.atan2(y, x) / d3_geo_radians,\n      Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians\n    ];\n  }\n\n  return interpolate;\n}\nd3.geo.greatCircle = d3.geo.circle;\nd3.geom = {};\n/**\n * Computes a contour for a given input grid function using the <a\n * href=\"http://en.wikipedia.org/wiki/Marching_squares\">marching\n * squares</a> algorithm. Returns the contour polygon as an array of points.\n *\n * @param grid a two-input function(x, y) that returns true for values\n * inside the contour and false for values outside the contour.\n * @param start an optional starting point [x, y] on the grid.\n * @returns polygon [[x1, y1], [x2, y2], ]\n */\nd3.geom.contour = function(grid, start) {\n  var s = start || d3_geom_contourStart(grid), // starting point\n      c = [],    // contour polygon\n      x = s[0],  // current x position\n      y = s[1],  // current y position\n      dx = 0,    // next x direction\n      dy = 0,    // next y direction\n      pdx = NaN, // previous x direction\n      pdy = NaN, // previous y direction\n      i = 0;\n\n  do {\n    // determine marching squares index\n    i = 0;\n    if (grid(x-1, y-1)) i += 1;\n    if (grid(x,   y-1)) i += 2;\n    if (grid(x-1, y  )) i += 4;\n    if (grid(x,   y  )) i += 8;\n\n    // determine next direction\n    if (i === 6) {\n      dx = pdy === -1 ? -1 : 1;\n      dy = 0;\n    } else if (i === 9) {\n      dx = 0;\n      dy = pdx === 1 ? -1 : 1;\n    } else {\n      dx = d3_geom_contourDx[i];\n      dy = d3_geom_contourDy[i];\n    }\n\n    // update contour polygon\n    if (dx != pdx && dy != pdy) {\n      c.push([x, y]);\n      pdx = dx;\n      pdy = dy;\n    }\n\n    x += dx;\n    y += dy;\n  } while (s[0] != x || s[1] != y);\n\n  return c;\n};\n\n// lookup tables for marching directions\nvar d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],\n    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];\n\nfunction d3_geom_contourStart(grid) {\n  var x = 0,\n      y = 0;\n\n  // search for a starting point; begin at origin\n  // and proceed along outward-expanding diagonals\n  while (true) {\n    if (grid(x,y)) {\n      return [x,y];\n    }\n    if (x === 0) {\n      x = y + 1;\n      y = 0;\n    } else {\n      x = x - 1;\n      y = y + 1;\n    }\n  }\n}\n/**\n * Computes the 2D convex hull of a set of points using Graham's scanning\n * algorithm. The algorithm has been implemented as described in Cormen,\n * Leiserson, and Rivest's Introduction to Algorithms. The running time of\n * this algorithm is O(n log n), where n is the number of input points.\n *\n * @param vertices [[x1, y1], [x2, y2], ]\n * @returns polygon [[x1, y1], [x2, y2], ]\n */\nd3.geom.hull = function(vertices) {\n  if (vertices.length < 3) return [];\n\n  var len = vertices.length,\n      plen = len - 1,\n      points = [],\n      stack = [],\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\n\n  // find the starting ref point: leftmost point with the minimum y coord\n  for (i=1; i<len; ++i) {\n    if (vertices[i][1] < vertices[h][1]) {\n      h = i;\n    } else if (vertices[i][1] == vertices[h][1]) {\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\n    }\n  }\n\n  // calculate polar angles from ref point and sort\n  for (i=0; i<len; ++i) {\n    if (i === h) continue;\n    y1 = vertices[i][1] - vertices[h][1];\n    x1 = vertices[i][0] - vertices[h][0];\n    points.push({angle: Math.atan2(y1, x1), index: i});\n  }\n  points.sort(function(a, b) { return a.angle - b.angle; });\n\n  // toss out duplicate angles\n  a = points[0].angle;\n  v = points[0].index;\n  u = 0;\n  for (i=1; i<plen; ++i) {\n    j = points[i].index;\n    if (a == points[i].angle) {\n      // keep angle for point most distant from the reference\n      x1 = vertices[v][0] - vertices[h][0];\n      y1 = vertices[v][1] - vertices[h][1];\n      x2 = vertices[j][0] - vertices[h][0];\n      y2 = vertices[j][1] - vertices[h][1];\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\n        points[i].index = -1;\n      } else {\n        points[u].index = -1;\n        a = points[i].angle;\n        u = i;\n        v = j;\n      }\n    } else {\n      a = points[i].angle;\n      u = i;\n      v = j;\n    }\n  }\n\n  // initialize the stack\n  stack.push(h);\n  for (i=0, j=0; i<2; ++j) {\n    if (points[j].index !== -1) {\n      stack.push(points[j].index);\n      i++;\n    }\n  }\n  sp = stack.length;\n\n  // do graham's scan\n  for (; j<plen; ++j) {\n    if (points[j].index === -1) continue; // skip tossed out points\n    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\n      --sp;\n    }\n    stack[sp++] = points[j].index;\n  }\n\n  // construct the hull\n  var poly = [];\n  for (i=0; i<sp; ++i) {\n    poly.push(vertices[stack[i]]);\n  }\n  return poly;\n}\n\n// are three points in counter-clockwise order?\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\n  var t, a, b, c, d, e, f;\n  t = v[i1]; a = t[0]; b = t[1];\n  t = v[i2]; c = t[0]; d = t[1];\n  t = v[i3]; e = t[0]; f = t[1];\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\n}\n// Note: requires coordinates to be counterclockwise and convex!\nd3.geom.polygon = function(coordinates) {\n\n  coordinates.area = function() {\n    var i = 0,\n        n = coordinates.length,\n        a = coordinates[n - 1][0] * coordinates[0][1],\n        b = coordinates[n - 1][1] * coordinates[0][0];\n    while (++i < n) {\n      a += coordinates[i - 1][0] * coordinates[i][1];\n      b += coordinates[i - 1][1] * coordinates[i][0];\n    }\n    return (b - a) * .5;\n  };\n\n  coordinates.centroid = function(k) {\n    var i = -1,\n        n = coordinates.length,\n        x = 0,\n        y = 0,\n        a,\n        b = coordinates[n - 1],\n        c;\n    if (!arguments.length) k = -1 / (6 * coordinates.area());\n    while (++i < n) {\n      a = b;\n      b = coordinates[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [x * k, y * k];\n  };\n\n  // The Sutherland-Hodgman clipping algorithm.\n  coordinates.clip = function(subject) {\n    var input,\n        i = -1,\n        n = coordinates.length,\n        j,\n        m,\n        a = coordinates[n - 1],\n        b,\n        c,\n        d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = coordinates[i];\n      c = input[(m = input.length) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      a = b;\n    }\n    return subject;\n  };\n\n  return coordinates;\n};\n\nfunction d3_geom_polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\nfunction d3_geom_polygonIntersect(c, d, a, b) {\n  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],\n      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],\n      x13 = x1 - x3,\n      x21 = x2 - x1,\n      x43 = x4 - x3,\n      y13 = y1 - y3,\n      y21 = y2 - y1,\n      y43 = y4 - y3,\n      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];\n}\n// Adapted from Nicolas Garcia Belmonte's JIT implementation:\n// http://blog.thejit.org/2010/02/12/voronoi-tessellation/\n// http://blog.thejit.org/assets/voronoijs/voronoi.js\n// See lib/jit/LICENSE for details.\n\n// Notes:\n//\n// This implementation does not clip the returned polygons, so if you want to\n// clip them to a particular shape you will need to do that either in SVG or by\n// post-processing with d3.geom.polygon's clip method.\n//\n// If any vertices are coincident or have NaN positions, the behavior of this\n// method is undefined. Most likely invalid polygons will be returned. You\n// should filter invalid points, and consolidate coincident points, before\n// computing the tessellation.\n\n/**\n * @param vertices [[x1, y1], [x2, y2], ]\n * @returns polygons [[[x1, y1], [x2, y2], ], ]\n */\nd3.geom.voronoi = function(vertices) {\n  var polygons = vertices.map(function() { return []; });\n\n  d3_voronoi_tessellate(vertices, function(e) {\n    var s1,\n        s2,\n        x1,\n        x2,\n        y1,\n        y2;\n    if (e.a === 1 && e.b >= 0) {\n      s1 = e.ep.r;\n      s2 = e.ep.l;\n    } else {\n      s1 = e.ep.l;\n      s2 = e.ep.r;\n    }\n    if (e.a === 1) {\n      y1 = s1 ? s1.y : -1e6;\n      x1 = e.c - e.b * y1;\n      y2 = s2 ? s2.y : 1e6;\n      x2 = e.c - e.b * y2;\n    } else {\n      x1 = s1 ? s1.x : -1e6;\n      y1 = e.c - e.a * x1;\n      x2 = s2 ? s2.x : 1e6;\n      y2 = e.c - e.a * x2;\n    }\n    var v1 = [x1, y1],\n        v2 = [x2, y2];\n    polygons[e.region.l.index].push(v1, v2);\n    polygons[e.region.r.index].push(v1, v2);\n  });\n\n  // Reconnect the polygon segments into counterclockwise loops.\n  return polygons.map(function(polygon, i) {\n    var cx = vertices[i][0],\n        cy = vertices[i][1];\n    polygon.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    return polygon.sort(function(a, b) {\n      return a.angle - b.angle;\n    }).filter(function(d, i) {\n      return !i || (d.angle - polygon[i - 1].angle > 1e-10);\n    });\n  });\n};\n\nvar d3_voronoi_opposite = {\"l\": \"r\", \"r\": \"l\"};\n\nfunction d3_voronoi_tessellate(vertices, callback) {\n\n  var Sites = {\n    list: vertices\n      .map(function(v, i) {\n        return {\n          index: i,\n          x: v[0],\n          y: v[1]\n        };\n      })\n      .sort(function(a, b) {\n        return a.y < b.y ? -1\n          : a.y > b.y ? 1\n          : a.x < b.x ? -1\n          : a.x > b.x ? 1\n          : 0;\n      }),\n    bottomSite: null\n  };\n\n  var EdgeList = {\n    list: [],\n    leftEnd: null,\n    rightEnd: null,\n\n    init: function() {\n      EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.leftEnd.r = EdgeList.rightEnd;\n      EdgeList.rightEnd.l = EdgeList.leftEnd;\n      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\n    },\n\n    createHalfEdge: function(edge, side) {\n      return {\n        edge: edge,\n        side: side,\n        vertex: null,\n        \"l\": null,\n        \"r\": null\n      };\n    },\n\n    insert: function(lb, he) {\n      he.l = lb;\n      he.r = lb.r;\n      lb.r.l = he;\n      lb.r = he;\n    },\n\n    leftBound: function(p) {\n      var he = EdgeList.leftEnd;\n      do {\n        he = he.r;\n      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\n      he = he.l;\n      return he;\n    },\n\n    del: function(he) {\n      he.l.r = he.r;\n      he.r.l = he.l;\n      he.edge = null;\n    },\n\n    right: function(he) {\n      return he.r;\n    },\n\n    left: function(he) {\n      return he.l;\n    },\n\n    leftRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[he.side];\n    },\n\n    rightRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[d3_voronoi_opposite[he.side]];\n    }\n  };\n\n  var Geom = {\n\n    bisect: function(s1, s2) {\n      var newEdge = {\n        region: {\"l\": s1, \"r\": s2},\n        ep: {\"l\": null, \"r\": null}\n      };\n\n      var dx = s2.x - s1.x,\n          dy = s2.y - s1.y,\n          adx = dx > 0 ? dx : -dx,\n          ady = dy > 0 ? dy : -dy;\n\n      newEdge.c = s1.x * dx + s1.y * dy\n          + (dx * dx + dy * dy) * .5;\n\n      if (adx > ady) {\n        newEdge.a = 1;\n        newEdge.b = dy / dx;\n        newEdge.c /= dx;\n      } else {\n        newEdge.b = 1;\n        newEdge.a = dx / dy;\n        newEdge.c /= dy;\n      }\n\n      return newEdge;\n    },\n\n    intersect: function(el1, el2) {\n      var e1 = el1.edge,\n          e2 = el2.edge;\n      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {\n        return null;\n      }\n      var d = (e1.a * e2.b) - (e1.b * e2.a);\n      if (Math.abs(d) < 1e-10) {\n        return null;\n      }\n      var xint = (e1.c * e2.b - e2.c * e1.b) / d,\n          yint = (e2.c * e1.a - e1.c * e2.a) / d,\n          e1r = e1.region.r,\n          e2r = e2.region.r,\n          el,\n          e;\n      if ((e1r.y < e2r.y) ||\n         (e1r.y == e2r.y && e1r.x < e2r.x)) {\n        el = el1;\n        e = e1;\n      } else {\n        el = el2;\n        e = e2;\n      }\n      var rightOfSite = (xint >= e.region.r.x);\n      if ((rightOfSite && (el.side === \"l\")) ||\n        (!rightOfSite && (el.side === \"r\"))) {\n        return null;\n      }\n      return {\n        x: xint,\n        y: yint\n      };\n    },\n\n    rightOf: function(he, p) {\n      var e = he.edge,\n          topsite = e.region.r,\n          rightOfSite = (p.x > topsite.x);\n\n      if (rightOfSite && (he.side === \"l\")) {\n        return 1;\n      }\n      if (!rightOfSite && (he.side === \"r\")) {\n        return 0;\n      }\n      if (e.a === 1) {\n        var dyp = p.y - topsite.y,\n            dxp = p.x - topsite.x,\n            fast = 0,\n            above = 0;\n\n        if ((!rightOfSite && (e.b < 0)) ||\n          (rightOfSite && (e.b >= 0))) {\n          above = fast = (dyp >= e.b * dxp);\n        } else {\n          above = ((p.x + p.y * e.b) > e.c);\n          if (e.b < 0) {\n            above = !above;\n          }\n          if (!above) {\n            fast = 1;\n          }\n        }\n        if (!fast) {\n          var dxs = topsite.x - e.region.l.x;\n          above = (e.b * (dxp * dxp - dyp * dyp)) <\n            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));\n\n          if (e.b < 0) {\n            above = !above;\n          }\n        }\n      } else /* e.b == 1 */ {\n        var yl = e.c - e.a * p.x,\n            t1 = p.y - yl,\n            t2 = p.x - topsite.x,\n            t3 = yl - topsite.y;\n\n        above = (t1 * t1) > (t2 * t2 + t3 * t3);\n      }\n      return he.side === \"l\" ? above : !above;\n    },\n\n    endPoint: function(edge, side, site) {\n      edge.ep[side] = site;\n      if (!edge.ep[d3_voronoi_opposite[side]]) return;\n      callback(edge);\n    },\n\n    distance: function(s, t) {\n      var dx = s.x - t.x,\n          dy = s.y - t.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  };\n\n  var EventQueue = {\n    list: [],\n\n    insert: function(he, site, offset) {\n      he.vertex = site;\n      he.ystar = site.y + offset;\n      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {\n        var next = list[i];\n        if (he.ystar > next.ystar ||\n          (he.ystar == next.ystar &&\n          site.x > next.vertex.x)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      list.splice(i, 0, he);\n    },\n\n    del: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}\n      ls.splice(i, 1);\n    },\n\n    empty: function() { return EventQueue.list.length === 0; },\n\n    nextEvent: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {\n        if (ls[i] == he) return ls[i+1];\n      }\n      return null;\n    },\n\n    min: function() {\n      var elem = EventQueue.list[0];\n      return {\n        x: elem.vertex.x,\n        y: elem.ystar\n      };\n    },\n\n    extractMin: function() {\n      return EventQueue.list.shift();\n    }\n  };\n\n  EdgeList.init();\n  Sites.bottomSite = Sites.list.shift();\n\n  var newSite = Sites.list.shift(), newIntStar;\n  var lbnd, rbnd, llbnd, rrbnd, bisector;\n  var bot, top, temp, p, v;\n  var e, pm;\n\n  while (true) {\n    if (!EventQueue.empty()) {\n      newIntStar = EventQueue.min();\n    }\n    if (newSite && (EventQueue.empty()\n      || newSite.y < newIntStar.y\n      || (newSite.y == newIntStar.y\n      && newSite.x < newIntStar.x))) { //new site is smallest\n      lbnd = EdgeList.leftBound(newSite);\n      rbnd = EdgeList.right(lbnd);\n      bot = EdgeList.rightRegion(lbnd);\n      e = Geom.bisect(bot, newSite);\n      bisector = EdgeList.createHalfEdge(e, \"l\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(lbnd, bisector);\n      if (p) {\n        EventQueue.del(lbnd);\n        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\n      }\n      lbnd = bisector;\n      bisector = EdgeList.createHalfEdge(e, \"r\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(bisector, rbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, newSite));\n      }\n      newSite = Sites.list.shift();\n    } else if (!EventQueue.empty()) { //intersection is smallest\n      lbnd = EventQueue.extractMin();\n      llbnd = EdgeList.left(lbnd);\n      rbnd = EdgeList.right(lbnd);\n      rrbnd = EdgeList.right(rbnd);\n      bot = EdgeList.leftRegion(lbnd);\n      top = EdgeList.rightRegion(rbnd);\n      v = lbnd.vertex;\n      Geom.endPoint(lbnd.edge, lbnd.side, v);\n      Geom.endPoint(rbnd.edge, rbnd.side, v);\n      EdgeList.del(lbnd);\n      EventQueue.del(rbnd);\n      EdgeList.del(rbnd);\n      pm = \"l\";\n      if (bot.y > top.y) {\n        temp = bot;\n        bot = top;\n        top = temp;\n        pm = \"r\";\n      }\n      e = Geom.bisect(bot, top);\n      bisector = EdgeList.createHalfEdge(e, pm);\n      EdgeList.insert(llbnd, bisector);\n      Geom.endPoint(e, d3_voronoi_opposite[pm], v);\n      p = Geom.intersect(llbnd, bisector);\n      if (p) {\n        EventQueue.del(llbnd);\n        EventQueue.insert(llbnd, p, Geom.distance(p, bot));\n      }\n      p = Geom.intersect(bisector, rrbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, bot));\n      }\n    } else {\n      break;\n    }\n  }//end while\n\n  for (lbnd = EdgeList.right(EdgeList.leftEnd);\n      lbnd != EdgeList.rightEnd;\n      lbnd = EdgeList.right(lbnd)) {\n    callback(lbnd.edge);\n  }\n}\n/**\n* @param vertices [[x1, y1], [x2, y2], ]\n* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], ]\n */\nd3.geom.delaunay = function(vertices) {\n  var edges = vertices.map(function() { return []; }),\n      triangles = [];\n\n  // Use the Voronoi tessellation to determine Delaunay edges.\n  d3_voronoi_tessellate(vertices, function(e) {\n    edges[e.region.l.index].push(vertices[e.region.r.index]);\n  });\n\n  // Reconnect the edges into counterclockwise triangles.\n  edges.forEach(function(edge, i) {\n    var v = vertices[i],\n        cx = v[0],\n        cy = v[1];\n    edge.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    edge.sort(function(a, b) {\n      return a.angle - b.angle;\n    });\n    for (var j = 0, m = edge.length - 1; j < m; j++) {\n      triangles.push([v, edge[j], edge[j + 1]]);\n    }\n  });\n\n  return triangles;\n};\n// Constructs a new quadtree for the specified array of points. A quadtree is a\n// two-dimensional recursive spatial subdivision. This implementation uses\n// square partitions, dividing each square into four equally-sized squares. Each\n// point exists in a unique node; if multiple points are in the same position,\n// some points may be stored on internal nodes rather than leaf nodes. Quadtrees\n// can be used to accelerate various spatial operations, such as the Barnes-Hut\n// approximation for computing n-body forces, or collision detection.\nd3.geom.quadtree = function(points, x1, y1, x2, y2) {\n  var p,\n      i = -1,\n      n = points.length;\n\n  // Type conversion for deprecated API.\n  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);\n\n  // Allow bounds to be specified explicitly.\n  if (arguments.length < 5) {\n    if (arguments.length === 3) {\n      y2 = x2 = y1;\n      y1 = x1;\n    } else {\n      x1 = y1 = Infinity;\n      x2 = y2 = -Infinity;\n\n      // Compute bounds.\n      while (++i < n) {\n        p = points[i];\n        if (p.x < x1) x1 = p.x;\n        if (p.y < y1) y1 = p.y;\n        if (p.x > x2) x2 = p.x;\n        if (p.y > y2) y2 = p.y;\n      }\n\n      // Squarify the bounds.\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      if (dx > dy) y2 = y1 + dx;\n      else x2 = x1 + dy;\n    }\n  }\n\n  // Recursively inserts the specified point p at the node n or one of its\n  // descendants. The bounds are defined by [x1, x2] and [y1, y2].\n  function insert(n, p, x1, y1, x2, y2) {\n    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points\n    if (n.leaf) {\n      var v = n.point;\n      if (v) {\n        // If the point at this leaf node is at the same position as the new\n        // point we are adding, we leave the point associated with the\n        // internal node while adding the new point to a child node. This\n        // avoids infinite recursion.\n        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {\n          insertChild(n, p, x1, y1, x2, y2);\n        } else {\n          n.point = null;\n          insertChild(n, v, x1, y1, x2, y2);\n          insertChild(n, p, x1, y1, x2, y2);\n        }\n      } else {\n        n.point = p;\n      }\n    } else {\n      insertChild(n, p, x1, y1, x2, y2);\n    }\n  }\n\n  // Recursively inserts the specified point p into a descendant of node n. The\n  // bounds are defined by [x1, x2] and [y1, y2].\n  function insertChild(n, p, x1, y1, x2, y2) {\n    // Compute the split point, and the quadrant in which to insert p.\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        right = p.x >= sx,\n        bottom = p.y >= sy,\n        i = (bottom << 1) + right;\n\n    // Recursively insert into the child node.\n    n.leaf = false;\n    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n\n    // Update the bounds as we recurse.\n    if (right) x1 = sx; else x2 = sx;\n    if (bottom) y1 = sy; else y2 = sy;\n    insert(n, p, x1, y1, x2, y2);\n  }\n\n  // Create the root node.\n  var root = d3_geom_quadtreeNode();\n\n  root.add = function(p) {\n    insert(root, p, x1, y1, x2, y2);\n  };\n\n  root.visit = function(f) {\n    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\n  };\n\n  // Insert all points.\n  points.forEach(root.add);\n  return root;\n};\n\nfunction d3_geom_quadtreeNode() {\n  return {\n    leaf: true,\n    nodes: [],\n    point: null\n  };\n}\n\nfunction d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n  if (!f(node, x1, y1, x2, y2)) {\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        children = node.nodes;\n    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n  }\n}\n\nfunction d3_geom_quadtreePoint(p) {\n  return {\n    x: p[0],\n    y: p[1]\n  };\n}\nd3.time = {};\n\nvar d3_time = Date;\n\nfunction d3_time_utc() {\n  this._ = new Date(arguments.length > 1\n      ? Date.UTC.apply(this, arguments)\n      : arguments[0]);\n}\n\nd3_time_utc.prototype = {\n  getDate: function() { return this._.getUTCDate(); },\n  getDay: function() { return this._.getUTCDay(); },\n  getFullYear: function() { return this._.getUTCFullYear(); },\n  getHours: function() { return this._.getUTCHours(); },\n  getMilliseconds: function() { return this._.getUTCMilliseconds(); },\n  getMinutes: function() { return this._.getUTCMinutes(); },\n  getMonth: function() { return this._.getUTCMonth(); },\n  getSeconds: function() { return this._.getUTCSeconds(); },\n  getTime: function() { return this._.getTime(); },\n  getTimezoneOffset: function() { return 0; },\n  valueOf: function() { return this._.valueOf(); },\n  setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); },\n  setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); },\n  setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); },\n  setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); },\n  setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); },\n  setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); },\n  setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); },\n  setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); },\n  setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); }\n};\n\nvar d3_time_prototype = Date.prototype;\nd3.time.format = function(template) {\n  var n = template.length;\n\n  function format(date) {\n    var string = [],\n        i = -1,\n        j = 0,\n        c,\n        f;\n    while (++i < n) {\n      if (template.charCodeAt(i) == 37) {\n        string.push(\n            template.substring(j, i),\n            (f = d3_time_formats[c = template.charAt(++i)])\n            ? f(date) : c);\n        j = i + 1;\n      }\n    }\n    string.push(template.substring(j, i));\n    return string.join(\"\");\n  }\n\n  format.parse = function(string) {\n    var d = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0},\n        i = d3_time_parse(d, template, string, 0);\n    if (i != string.length) return null;\n\n    // The am-pm flag is 0 for AM, and 1 for PM.\n    if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n    var date = new d3_time();\n    date.setFullYear(d.y, d.m, d.d);\n    date.setHours(d.H, d.M, d.S, d.L);\n    return date;\n  };\n\n  format.toString = function() {\n    return template;\n  };\n\n  return format;\n};\n\nfunction d3_time_parse(date, template, string, j) {\n  var c,\n      p,\n      i = 0,\n      n = template.length,\n      m = string.length;\n  while (i < n) {\n    if (j >= m) return -1;\n    c = template.charCodeAt(i++);\n    if (c == 37) {\n      p = d3_time_parsers[template.charAt(i++)];\n      if (!p || ((j = p(date, string, j)) < 0)) return -1;\n    } else if (c != string.charCodeAt(j++)) {\n      return -1;\n    }\n  }\n  return j;\n}\n\nvar d3_time_zfill2 = d3.format(\"02d\"),\n    d3_time_zfill3 = d3.format(\"03d\"),\n    d3_time_zfill4 = d3.format(\"04d\"),\n    d3_time_sfill2 = d3.format(\"2d\");\n\nvar d3_time_formats = {\n  a: function(d) { return d3_time_weekdays[d.getDay()].substring(0, 3); },\n  A: function(d) { return d3_time_weekdays[d.getDay()]; },\n  b: function(d) { return d3_time_months[d.getMonth()].substring(0, 3); },\n  B: function(d) { return d3_time_months[d.getMonth()]; },\n  c: d3.time.format(\"%a %b %e %H:%M:%S %Y\"),\n  d: function(d) { return d3_time_zfill2(d.getDate()); },\n  e: function(d) { return d3_time_sfill2(d.getDate()); },\n  H: function(d) { return d3_time_zfill2(d.getHours()); },\n  I: function(d) { return d3_time_zfill2(d.getHours() % 12 || 12); },\n  j: function(d) { return d3_time_zfill3(1 + d3.time.dayOfYear(d)); },\n  L: function(d) { return d3_time_zfill3(d.getMilliseconds()); },\n  m: function(d) { return d3_time_zfill2(d.getMonth() + 1); },\n  M: function(d) { return d3_time_zfill2(d.getMinutes()); },\n  p: function(d) { return d.getHours() >= 12 ? \"PM\" : \"AM\"; },\n  S: function(d) { return d3_time_zfill2(d.getSeconds()); },\n  U: function(d) { return d3_time_zfill2(d3.time.sundayOfYear(d)); },\n  w: function(d) { return d.getDay(); },\n  W: function(d) { return d3_time_zfill2(d3.time.mondayOfYear(d)); },\n  x: d3.time.format(\"%m/%d/%y\"),\n  X: d3.time.format(\"%H:%M:%S\"),\n  y: function(d) { return d3_time_zfill2(d.getFullYear() % 100); },\n  Y: function(d) { return d3_time_zfill4(d.getFullYear() % 10000); },\n  Z: d3_time_zone,\n  \"%\": function(d) { return \"%\"; }\n};\n\nvar d3_time_parsers = {\n  a: d3_time_parseWeekdayAbbrev,\n  A: d3_time_parseWeekday,\n  b: d3_time_parseMonthAbbrev,\n  B: d3_time_parseMonth,\n  c: d3_time_parseLocaleFull,\n  d: d3_time_parseDay,\n  e: d3_time_parseDay,\n  H: d3_time_parseHour24,\n  I: d3_time_parseHour24,\n  // j: function(d, s, i) { /*TODO day of year [001,366] */ return i; },\n  L: d3_time_parseMilliseconds,\n  m: d3_time_parseMonthNumber,\n  M: d3_time_parseMinutes,\n  p: d3_time_parseAmPm,\n  S: d3_time_parseSeconds,\n  // U: function(d, s, i) { /*TODO week number (sunday) [00,53] */ return i; },\n  // w: function(d, s, i) { /*TODO weekday [0,6] */ return i; },\n  // W: function(d, s, i) { /*TODO week number (monday) [00,53] */ return i; },\n  x: d3_time_parseLocaleDate,\n  X: d3_time_parseLocaleTime,\n  y: d3_time_parseYear,\n  Y: d3_time_parseFullYear\n  // ,\n  // Z: function(d, s, i) { /*TODO time zone */ return i; },\n  // \"%\": function(d, s, i) { /*TODO literal % */ return i; }\n};\n\n// Note: weekday is validated, but does not set the date.\nfunction d3_time_parseWeekdayAbbrev(date, string, i) {\n  return d3_time_weekdayAbbrevRe.test(string.substring(i, i += 3)) ? i : -1;\n}\n\n// Note: weekday is validated, but does not set the date.\nfunction d3_time_parseWeekday(date, string, i) {\n  d3_time_weekdayRe.lastIndex = 0;\n  var n = d3_time_weekdayRe.exec(string.substring(i, i + 10));\n  return n ? i += n[0].length : -1;\n}\n\nvar d3_time_weekdayAbbrevRe = /^(?:sun|mon|tue|wed|thu|fri|sat)/i,\n    d3_time_weekdayRe = /^(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)/i;\n    d3_time_weekdays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\nfunction d3_time_parseMonthAbbrev(date, string, i) {\n  var n = d3_time_monthAbbrevLookup.get(string.substring(i, i += 3).toLowerCase());\n  return n == null ? -1 : (date.m = n, i);\n}\n\nvar d3_time_monthAbbrevLookup = d3.map({\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  may: 4,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11\n});\n\nfunction d3_time_parseMonth(date, string, i) {\n  d3_time_monthRe.lastIndex = 0;\n  var n = d3_time_monthRe.exec(string.substring(i, i + 12));\n  return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\n}\n\nvar d3_time_monthRe = /^(?:January|February|March|April|May|June|July|August|September|October|November|December)/ig;\n\nvar d3_time_monthLookup = d3.map({\n  january: 0,\n  february: 1,\n  march: 2,\n  april: 3,\n  may: 4,\n  june: 5,\n  july: 6,\n  august: 7,\n  september: 8,\n  october: 9,\n  november: 10,\n  december: 11\n});\n\nvar d3_time_months = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\"\n];\n\nfunction d3_time_parseLocaleFull(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n}\n\nfunction d3_time_parseLocaleDate(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n}\n\nfunction d3_time_parseLocaleTime(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n}\n\nfunction d3_time_parseFullYear(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 4));\n  return n ? (date.y = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseYear(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.y = d3_time_century() + +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_century() {\n  return ~~(new Date().getFullYear() / 1000) * 1000;\n}\n\nfunction d3_time_parseMonthNumber(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.m = n[0] - 1, i += n[0].length) : -1;\n}\n\nfunction d3_time_parseDay(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.d = +n[0], i += n[0].length) : -1;\n}\n\n// Note: we don't validate that the hour is in the range [0,23] or [1,12].\nfunction d3_time_parseHour24(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.H = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseMinutes(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.M = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseSeconds(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.S = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseMilliseconds(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n  return n ? (date.L = +n[0], i += n[0].length) : -1;\n}\n\n// Note: we don't look at the next directive.\nvar d3_time_numberRe = /\\s*\\d+/;\n\nfunction d3_time_parseAmPm(date, string, i) {\n  var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());\n  return n == null ? -1 : (date.p = n, i);\n}\n\nvar d3_time_amPmLookup = d3.map({\n  am: 0,\n  pm: 1\n});\n\n// TODO table of time zone offset names?\nfunction d3_time_zone(d) {\n  var z = d.getTimezoneOffset(),\n      zs = z > 0 ? \"-\" : \"+\",\n      zh = ~~(Math.abs(z) / 60),\n      zm = Math.abs(z) % 60;\n  return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);\n}\nd3.time.format.utc = function(template) {\n  var local = d3.time.format(template);\n\n  function format(date) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time();\n      utc._ = date;\n      return local(utc);\n    } finally {\n      d3_time = Date;\n    }\n  }\n\n  format.parse = function(string) {\n    try {\n      d3_time = d3_time_utc;\n      var date = local.parse(string);\n      return date && date._;\n    } finally {\n      d3_time = Date;\n    }\n  };\n\n  format.toString = local.toString;\n\n  return format;\n};\nvar d3_time_formatIso = d3.time.format.utc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n\nd3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;\n\nfunction d3_time_formatIsoNative(date) {\n  return date.toISOString();\n}\n\nd3_time_formatIsoNative.parse = function(string) {\n  return new Date(string);\n};\n\nd3_time_formatIsoNative.toString = d3_time_formatIso.toString;\nfunction d3_time_interval(local, step, number) {\n\n  function round(date) {\n    var d0 = local(date), d1 = offset(d0, 1);\n    return date - d0 < d1 - date ? d0 : d1;\n  }\n\n  function ceil(date) {\n    step(date = local(new d3_time(date - 1)), 1);\n    return date;\n  }\n\n  function offset(date, k) {\n    step(date = new d3_time(+date), k);\n    return date;\n  }\n\n  function range(t0, t1, dt) {\n    var time = ceil(t0), times = [];\n    if (dt > 1) {\n      while (time < t1) {\n        if (!(number(time) % dt)) times.push(new Date(+time));\n        step(time, 1);\n      }\n    } else {\n      while (time < t1) times.push(new Date(+time)), step(time, 1);\n    }\n    return times;\n  }\n\n  function range_utc(t0, t1, dt) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time_utc();\n      utc._ = t0;\n      return range(utc, t1, dt);\n    } finally {\n      d3_time = Date;\n    }\n  }\n\n  local.floor = local;\n  local.round = round;\n  local.ceil = ceil;\n  local.offset = offset;\n  local.range = range;\n\n  var utc = local.utc = d3_time_interval_utc(local);\n  utc.floor = utc;\n  utc.round = d3_time_interval_utc(round);\n  utc.ceil = d3_time_interval_utc(ceil);\n  utc.offset = d3_time_interval_utc(offset);\n  utc.range = range_utc;\n\n  return local;\n}\n\nfunction d3_time_interval_utc(method) {\n  return function(date, k) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time_utc();\n      utc._ = date;\n      return method(utc, k)._;\n    } finally {\n      d3_time = Date;\n    }\n  };\n}\nd3.time.second = d3_time_interval(function(date) {\n  return new d3_time(Math.floor(date / 1e3) * 1e3);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 1e3); // DST breaks setSeconds\n}, function(date) {\n  return date.getSeconds();\n});\n\nd3.time.seconds = d3.time.second.range;\nd3.time.seconds.utc = d3.time.second.utc.range;\nd3.time.minute = d3_time_interval(function(date) {\n  return new d3_time(Math.floor(date / 6e4) * 6e4);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 6e4); // DST breaks setMinutes\n}, function(date) {\n  return date.getMinutes();\n});\n\nd3.time.minutes = d3.time.minute.range;\nd3.time.minutes.utc = d3.time.minute.utc.range;\nd3.time.hour = d3_time_interval(function(date) {\n  var timezone = date.getTimezoneOffset() / 60;\n  return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 36e5); // DST breaks setHours\n}, function(date) {\n  return date.getHours();\n});\n\nd3.time.hours = d3.time.hour.range;\nd3.time.hours.utc = d3.time.hour.utc.range;\nd3.time.day = d3_time_interval(function(date) {\n  return new d3_time(date.getFullYear(), date.getMonth(), date.getDate());\n}, function(date, offset) {\n  date.setDate(date.getDate() + offset);\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nd3.time.days = d3.time.day.range;\nd3.time.days.utc = d3.time.day.utc.range;\n\nd3.time.dayOfYear = function(date) {\n  var year = d3.time.year(date);\n  return Math.floor((date - year) / 864e5 - (date.getTimezoneOffset() - year.getTimezoneOffset()) / 1440);\n};\nd3_time_weekdays.forEach(function(day, i) {\n  day = day.toLowerCase();\n  i = 7 - i;\n\n  var interval = d3.time[day] = d3_time_interval(function(date) {\n    (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n    return date;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + Math.floor(offset) * 7);\n  }, function(date) {\n    var day = d3.time.year(date).getDay();\n    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n  });\n\n  d3.time[day + \"s\"] = interval.range;\n  d3.time[day + \"s\"].utc = interval.utc.range;\n\n  d3.time[day + \"OfYear\"] = function(date) {\n    var day = d3.time.year(date).getDay();\n    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);\n  };\n});\n\nd3.time.week = d3.time.sunday;\nd3.time.weeks = d3.time.sunday.range;\nd3.time.weeks.utc = d3.time.sunday.utc.range;\nd3.time.weekOfYear = d3.time.sundayOfYear;\nd3.time.month = d3_time_interval(function(date) {\n  return new d3_time(date.getFullYear(), date.getMonth(), 1);\n}, function(date, offset) {\n  date.setMonth(date.getMonth() + offset);\n}, function(date) {\n  return date.getMonth();\n});\n\nd3.time.months = d3.time.month.range;\nd3.time.months.utc = d3.time.month.utc.range;\nd3.time.year = d3_time_interval(function(date) {\n  return new d3_time(date.getFullYear(), 0, 1);\n}, function(date, offset) {\n  date.setFullYear(date.getFullYear() + offset);\n}, function(date) {\n  return date.getFullYear();\n});\n\nd3.time.years = d3.time.year.range;\nd3.time.years.utc = d3.time.year.utc.range;\nfunction d3_time_scale(linear, methods, format) {\n\n  function scale(x) {\n    return linear(x);\n  }\n\n  scale.invert = function(x) {\n    return d3_time_scaleDate(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n    linear.domain(x);\n    return scale;\n  };\n\n  scale.nice = function(m) {\n    var extent = d3_time_scaleExtent(scale.domain());\n    return scale.domain([m.floor(extent[0]), m.ceil(extent[1])]);\n  };\n\n  scale.ticks = function(m, k) {\n    var extent = d3_time_scaleExtent(scale.domain());\n    if (typeof m !== \"function\") {\n      var span = extent[1] - extent[0],\n          target = span / m,\n          i = d3.bisect(d3_time_scaleSteps, target);\n      if (i == d3_time_scaleSteps.length) return methods.year(extent, m);\n      if (!i) return linear.ticks(m).map(d3_time_scaleDate);\n      if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;\n      m = methods[i];\n      k = m[1];\n      m = m[0].range;\n    }\n    return m(extent[0], new Date(+extent[1] + 1), k); // inclusive upper bound\n  };\n\n  scale.tickFormat = function() {\n    return format;\n  };\n\n  scale.copy = function() {\n    return d3_time_scale(linear.copy(), methods, format);\n  };\n\n  // TOOD expose d3_scale_linear_rebind?\n  return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n}\n\n// TODO expose d3_scaleExtent?\nfunction d3_time_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction d3_time_scaleDate(t) {\n  return new Date(t);\n}\n\nfunction d3_time_scaleFormat(formats) {\n  return function(date) {\n    var i = formats.length - 1, f = formats[i];\n    while (!f[1](date)) f = formats[--i];\n    return f[0](date);\n  };\n}\n\nfunction d3_time_scaleSetYear(y) {\n  var d = new Date(y, 0, 1);\n  d.setFullYear(y); // Y2K fail\n  return d;\n}\n\nfunction d3_time_scaleGetYear(d) {\n  var y = d.getFullYear(),\n      d0 = d3_time_scaleSetYear(y),\n      d1 = d3_time_scaleSetYear(y + 1);\n  return y + (d - d0) / (d1 - d0);\n}\n\nvar d3_time_scaleSteps = [\n  1e3,    // 1-second\n  5e3,    // 5-second\n  15e3,   // 15-second\n  3e4,    // 30-second\n  6e4,    // 1-minute\n  3e5,    // 5-minute\n  9e5,    // 15-minute\n  18e5,   // 30-minute\n  36e5,   // 1-hour\n  108e5,  // 3-hour\n  216e5,  // 6-hour\n  432e5,  // 12-hour\n  864e5,  // 1-day\n  1728e5, // 2-day\n  6048e5, // 1-week\n  2592e6, // 1-month\n  7776e6, // 3-month\n  31536e6 // 1-year\n];\n\nvar d3_time_scaleLocalMethods = [\n  [d3.time.second, 1],\n  [d3.time.second, 5],\n  [d3.time.second, 15],\n  [d3.time.second, 30],\n  [d3.time.minute, 1],\n  [d3.time.minute, 5],\n  [d3.time.minute, 15],\n  [d3.time.minute, 30],\n  [d3.time.hour, 1],\n  [d3.time.hour, 3],\n  [d3.time.hour, 6],\n  [d3.time.hour, 12],\n  [d3.time.day, 1],\n  [d3.time.day, 2],\n  [d3.time.week, 1],\n  [d3.time.month, 1],\n  [d3.time.month, 3],\n  [d3.time.year, 1]\n];\n\nvar d3_time_scaleLocalFormats = [\n  [d3.time.format(\"%Y\"), function(d) { return true; }],\n  [d3.time.format(\"%B\"), function(d) { return d.getMonth(); }],\n  [d3.time.format(\"%b %d\"), function(d) { return d.getDate() != 1; }],\n  [d3.time.format(\"%a %d\"), function(d) { return d.getDay() && d.getDate() != 1; }],\n  [d3.time.format(\"%I %p\"), function(d) { return d.getHours(); }],\n  [d3.time.format(\"%I:%M\"), function(d) { return d.getMinutes(); }],\n  [d3.time.format(\":%S\"), function(d) { return d.getSeconds(); }],\n  [d3.time.format(\".%L\"), function(d) { return d.getMilliseconds(); }]\n];\n\nvar d3_time_scaleLinear = d3.scale.linear(),\n    d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);\n\nd3_time_scaleLocalMethods.year = function(extent, m) {\n  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);\n};\n\nd3.time.scale = function() {\n  return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n};\nvar d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {\n  return [m[0].utc, m[1]];\n});\n\nvar d3_time_scaleUTCFormats = [\n  [d3.time.format.utc(\"%Y\"), function(d) { return true; }],\n  [d3.time.format.utc(\"%B\"), function(d) { return d.getUTCMonth(); }],\n  [d3.time.format.utc(\"%b %d\"), function(d) { return d.getUTCDate() != 1; }],\n  [d3.time.format.utc(\"%a %d\"), function(d) { return d.getUTCDay() && d.getUTCDate() != 1; }],\n  [d3.time.format.utc(\"%I %p\"), function(d) { return d.getUTCHours(); }],\n  [d3.time.format.utc(\"%I:%M\"), function(d) { return d.getUTCMinutes(); }],\n  [d3.time.format.utc(\":%S\"), function(d) { return d.getUTCSeconds(); }],\n  [d3.time.format.utc(\".%L\"), function(d) { return d.getUTCMilliseconds(); }]\n];\n\nvar d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);\n\nfunction d3_time_scaleUTCSetYear(y) {\n  var d = new Date(Date.UTC(y, 0, 1));\n  d.setUTCFullYear(y); // Y2K fail\n  return d;\n}\n\nfunction d3_time_scaleUTCGetYear(d) {\n  var y = d.getUTCFullYear(),\n      d0 = d3_time_scaleUTCSetYear(y),\n      d1 = d3_time_scaleUTCSetYear(y + 1);\n  return y + (d - d0) / (d1 - d0);\n}\n\nd3_time_scaleUTCMethods.year = function(extent, m) {\n  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);\n};\n\nd3.time.scale.utc = function() {\n  return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);\n};\n})();\n","/home/travis/build/npmtest/node-npmtest-stackvis/node_modules/stackvis/share/icicle.js":"/*\n * icicle.js: implements icicle visualization for stacks\n */\n\n/* Configuration */\nvar svSvgWidth = null;\t\t/* image width (null to auto-compute) */\nvar svSvgHeight = null;\t\t/* image height (null to auto-compute) */\nvar svAxisLabelWidth = 45;\t/* width of axis labels */\nvar svChartWidth = null;\t/* width of chart part of image */\nvar svChartHeight = null;\t/* height of chart part of image */\nvar svGrowDown = false;\t\t/* if true, stacks are drawn growing down */\nvar svTransitionTime = 2000;\t/* time for transition */\nvar svCornerPixels = 3;\t\t/* radius of rounded corners */\nvar svTextPaddingLeft = 5;\t/* padding-left on rectangle labels */\nvar svTextPaddingRight = 10;\t/* pading-right on rectangle labels */\nvar svTextPaddingTop = '1.2em';\t/* padding-top on rectangle labels */\nvar svColorMode = 'mono';\t/* coloring mode */\nvar svDetailMode = 'popout';\t/* detail display mode (\"zoom\" or \"popout\") */\n\n/* Program state */\nvar svRawData;\t\t\t/* raw data, filled in by wrapper code */\nvar svTooltipBox;\t\t/* tooltip box (D3 selection) */\nvar svPopoutBox;\t\t/* popout detail box (D3 selection) */\nvar svFlameGraph;\t\t/* main flame graph object */\nvar svContext = {\n\t'detailClose': svDetailClose,\n\t'detailOpen': svDetailOpen,\n\t'mouseout': function () {\n\t\tsvTooltipBox.text('').style('opacity', null);\n\t},\n\t'mouseover': function (d, det) {\n\t\tvar text, left, top;\n\n\t\t/* escape the key */\n\t\tsvTooltipBox.text(det['label']);\n\t\ttext = svTooltipBox.html();\n\n\t\ttext = '<strong>' + text + '</strong><br />';\n\t\ttext += '<strong>Top of stack</strong>: ' +\n\t\t    det['pctUnique'] + '% of all samples ' +\n\t\t    '(' + det['nunique'] + ' of ' +\n\t\t    det['nallsamples'] + ' total samples)<br />';\n\t\ttext += '<strong>On stack</strong>: ' +\n\t\t    det['pctSamples'] + '% of all samples ' +\n\t\t    '(' + det['nsamples'] + ' of ' +\n\t\t    det['nallsamples'] + ' total samples)';\n\n\t\tleft = det['x'] + 'px';\n\t\ttop = (det['y'] -\n\t\t    parseInt(svTooltipBox.style('height'), 10)) + 'px';\n\t\tsvTooltipBox.html(text);\n\t\tsvTooltipBox.style('left', left);\n\t\tsvTooltipBox.style('top', top);\n\t\tsvTooltipBox.style('opacity', 0.9);\n\t}\n};\n\nwindow.onload = svInit;\n\nfunction svInit()\n{\n\tsvTooltipBox = d3.select('#svTooltip');\n\tsvPopoutBox = d3.select('#svPopout');\n\n\tsvFillData(svRawData);\n\tsvFlameGraph = new FlameGraph(d3.select('#chart'), svRawData,\n\t    svSvgWidth, svSvgHeight, svContext, {\n\t        'coloring': svColorMode,\n\t\t'growDown': svGrowDown,\n\t\t'axisLabels': true\n\t    });\n}\n\nfunction svFillData(tree)\n{\n\tvar key, rem;\n\n\tfor (key in tree) {\n\t\tsvFillData(tree[key].svChildren);\n\n\t\trem = tree[key].svUnique;\n\t\tif (rem > 0) {\n\t\t\ttree[key].svChildren[''] = {\n\t\t\t    'svSynthetic': true,\n\t\t\t    'svUnique': rem,\n\t\t\t    'svTotal': rem,\n\t\t\t    'svChildren': {}\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction svColorMono(d, det)\n{\n\tif (d.data.value.svSynthetic)\n\t\treturn ('#ffffff');\n\n\tvar s = 20, splus = 80;\n\tvar sratio;\n\n\t/*\n\t * This version colors the block based on its percentage contribution of\n\t * overall time.\n\t */\n\tsratio = d.data.value.svUnique / det['maxUnique'];\n\n\tvar rh = 24;\n\tvar rs = (s + sratio * splus) / 100;\n\tvar rv = 0.95;\n\tvar rgb = convertHsvToRgb(rh, rs, rv);\n\treturn ('rgb(' + rgb.join(',') + ')');\n}\n\nfunction svDetailClose()\n{\n\tif (svDetailMode != 'zoom') {\n\t\tsvPopoutBox.html('');\n\t\tsvPopoutBox.style('opacity', null);\n\t\tsvPopoutBox.style('z-index', null);\n\t} else {\n\t\tsvFlameGraph.zoomSet({ 'x': 0, 'dx': 1, 'y': 0 });\n\t}\n}\n\n/*\n * Input: \"d\", a D3 node from the layout, typically resembling:\n *     parent: ...,  // parent D3 node\n *     data: {\n *         key: ..., // function name\n *         value: {\n *             svTotal: ...,\n *             svUnique: ...,\n *             svChildren: ...\n *         }\n *     }\n * Output: an object describing the raw flame graph data, matching the form:\n *     \"\": {\n *         svTotal: ...\n *         svUnique: ...\n *         svChildren: {\n *             key1: { // function name\n *                 svTotal: ...\n *                 svUnique: ...\n *                 svChildren: ...\n *             },\n *             ...\n *         }\n *     }\n */\nfunction svMakeSubgraphData(d)\n{\n\t/*\n\t * First, construct everything from the current node to all of its\n\t * leafs.\n\t */\n\tvar tree, oldtree;\n\n\ttree = {};\n\ttree[d.data.key] = d.data.value;\n\n\twhile (d.parent !== undefined) {\n\t\toldtree = tree;\n\t\ttree = {};\n\t\ttree[d.parent.data.key] = {\n\t\t    'svUnique': d.parent.data.value.svUnique,\n\t\t    'svTotal': d.parent.data.value.svTotal,\n\t\t    'svChildren': oldtree\n\t\t};\n\t\td = d.parent;\n\t}\n\n\treturn (tree);\n}\n\nfunction svDetailOpen(d)\n{\n\tif (svDetailMode != 'zoom') {\n\t\tsvPopoutBox.html('');\n\t\t/* jsl:ignore */\n\t\tnew FlameGraph(svPopoutBox, svMakeSubgraphData(d), null, null,\n\t\t    svContext, {\n\t\t\t'coloring': svColorMode,\n\t\t\t'growDown': svGrowDown\n\t\t    });\n\t\t/* jsl:end */\n\t\tsvPopoutBox.style('z-index', 1);\n\t\tsvPopoutBox.style('opacity', 1);\n\t} else {\n\t\tsvFlameGraph.zoomSet(d);\n\t}\n}\n\n/*\n * Build a flame graph rooted at the given \"node\" (a D3 selection) with the\n * given \"rawdata\" tree.  The graph will have size defined by \"pwidth\" and\n * \"pheight\".  \"context\" is used for notifications about UI actions.\n */\nfunction FlameGraph(node, rawdata, pwidth, pheight, context, options)\n{\n\tvar axiswidth, chartheight, rect, scale, nodeid, axis, data;\n\tvar fg = this;\n\n\tthis.fg_context = context;\n\tthis.fg_maxdepth = 0;\n\tthis.fg_maxunique = 0;\n\tthis.fg_depthsamples = [];\n\tthis.computeDepth(rawdata, 0);\n\n\tif (options.axisLabels)\n\t\taxiswidth = this.fg_axiswidth = svAxisLabelWidth;\n\telse\n\t\taxiswidth = this.fg_axiswidth = 0;\n\n\tthis.fg_svgwidth = pwidth !== null ? pwidth :\n\t    parseInt(node.style('width'), 10);\n\tthis.fg_svgheight = pheight !== null ? pheight : 25 * this.fg_maxdepth;\n\tthis.fg_chartwidth = this.fg_svgwidth - axiswidth;\n\tchartheight = this.fg_chartheight = this.fg_svgheight - axiswidth;\n\n\tthis.fg_xscale =\n\t    d3.scale.linear().range([0, this.fg_chartwidth]);\n\tthis.fg_yscale =\n\t    d3.scale.linear().range([0, this.fg_chartheight]);\n\n\tthis.fg_svg = node.append('svg:svg');\n\tthis.fg_svg.attr('width', this.fg_svgwidth);\n\tthis.fg_svg.attr('height', this.fg_svgheight);\n\n\t/* Create a background rectangle that resets the view when clicked. */\n\trect = this.fg_svg.append('svg:rect');\n\trect.attr('class', 'svBackground');\n\trect.attr('width', this.fg_svgwidth);\n\trect.attr('height', this.fg_svgheight);\n\trect.attr('fill', '#ffffff');\n\trect.on('click', this.detailClose.bind(this));\n\n\t/* Configure the partition layout. */\n\tthis.fg_part = d3.layout.partition();\n\tthis.fg_part.children(\n\t    function (d) { return (d3.entries(d.value.svChildren)); });\n\tthis.fg_part.value(function (d) { return (d.value.svTotal); });\n\tthis.fg_part.sort(function (d1, d2) {\n\t\treturn (d1.data.key.localeCompare(d2.data.key));\n\t});\n\n\t/* Configure the color function. */\n\tif (options.coloring == 'random') {\n\t\tscale = d3.scale.category20c();\n\t\tthis.fg_color = function (d) { return (scale(d.data.key)); };\n\t} else {\n\t\tthis.fg_color = function (d) {\n\t\t    return (svColorMono(d, { 'maxUnique': fg.fg_maxunique }));\n\t\t};\n\t}\n\n\t/* Configure the actual D3 components. */\n\tnodeid = this.fg_nodeid = function (d) {\n\t\treturn (encodeURIComponent([\n\t\t    d.data.key,\n\t\t    fg.fg_yscale(d.y),\n\t\t    fg.fg_xscale(d.x) ].join('@')));\n\t};\n\tthis.fg_rectwidth = function (d) { return (fg.fg_xscale(d.dx)); };\n\tthis.fg_height = function (d) { return (fg.fg_yscale(d.dy)); };\n\tthis.fg_textwidth = function (d) {\n\t\treturn (Math.max(0, fg.fg_rectwidth(d) - svTextPaddingRight));\n\t};\n\tthis.fg_x = function (d) {\n\t    return (fg.fg_xscale(d.x) + fg.fg_axiswidth); };\n\n\tif (options.growDown)\n\t\tthis.fg_y =\n\t\t    function (d) { return (fg.fg_yscale(d.y)); };\n\telse\n\t\tthis.fg_y = function (d) {\n\t\t    return (chartheight - fg.fg_yscale(d.y) -\n\t\t        2 * fg.fg_height(d));\n\t\t};\n\n\tdata = this.fg_part(d3.entries(rawdata)[0]);\n\tthis.fg_rects = this.fg_svg.selectAll('rect').data(data).\n\t    enter().append('svg:rect').\n\t    attr('class', function (d) {\n\t\treturn (d.data.value.svSynthetic ?  'svBoxSynthetic' : 'svBox');\n\t    }).\n\t    attr('x', this.fg_x).\n\t    attr('y', this.fg_y).\n\t    attr('rx', svCornerPixels).\n\t    attr('ry', svCornerPixels).\n\t    attr('height', this.fg_height).\n\t    attr('width', this.fg_rectwidth).\n\t    attr('fill', this.fg_color).\n\t    on('click', this.detailOpen.bind(this)).\n\t    on('mouseover', this.mouseover.bind(this)).\n\t    on('mouseout', this.mouseout.bind(this));\n\tthis.fg_clips = this.fg_svg.selectAll('clipPath').data(data).\n\t    enter().append('svg:clipPath').\n\t    attr('id', nodeid).\n\t    append('svg:rect').\n\t    attr('x', this.fg_x).\n\t    attr('y', this.fg_y).\n\t    attr('width', this.fg_textwidth).\n\t    attr('height', this.fg_height);\n\tthis.fg_text = this.fg_svg.selectAll('text').data(data).\n\t    enter().append('text').\n\t    attr('class', 'svBoxLabel').\n\t    attr('x', this.fg_x).\n\t    attr('y', this.fg_y).\n\t    attr('dx', svTextPaddingLeft).\n\t    attr('dy', svTextPaddingTop).\n\t    attr('clip-path', function (d) {\n\t\treturn ('url(\"#' + nodeid(d) + '\")');\n\t    }).\n\t    on('click', this.detailOpen.bind(this)).\n\t    on('mouseover', this.mouseover.bind(this)).\n\t    on('mouseout', this.mouseout.bind(this)).\n\t    text(function (d) { return (d.data.key); });\n\n\tif (options.axisLabels) {\n\t\taxis = this.fg_svg.append('text');\n\t\taxis.attr('class', 'svYAxisLabel');\n\t\taxis.attr('x', -this.fg_svgheight);\n\t\taxis.attr('dx', '8em');\n\t\taxis.attr('y', '30px');\n\t\taxis.attr('transform', 'rotate(-90)');\n\t\taxis.text('Call Stacks');\n\n\t\taxis = this.fg_svg.append('text');\n\t\taxis.attr('class', 'svYAxisLabel');\n\t\taxis.attr('x', '30px');\n\t\taxis.attr('dx', '8em');\n\t\t/*\n\t\t * Magic constants here:\n\t\t *   30 is the height of the label (since we're specifying the\n\t\t *   top coordinate), and 25 is the height of each block\n\t\t *   (because there's an invisible row we want to cover up).\n\t\t */\n\t\taxis.attr('y', this.fg_svgheight - 30 - 25);\n\t\taxis.attr('width', this.fg_svgwidth - 30);\n\t\taxis.text('Percentage of Samples');\n\t}\n}\n\nFlameGraph.prototype.computeDepth = function (tree, depth)\n{\n\tvar key, rem;\n\n\tif (depth > this.fg_maxdepth)\n\t\tthis.fg_maxdepth = depth;\n\n\tif (depth >= this.fg_depthsamples.length)\n\t\tthis.fg_depthsamples[depth] = 0;\n\n\tfor (key in tree) {\n\t\tif (tree[key].svUnique > this.fg_maxunique)\n\t\t\tthis.fg_maxunique = tree[key].svUnique;\n\t\tthis.fg_depthsamples[depth] += tree[key].svTotal;\n\t\tthis.computeDepth(tree[key].svChildren, depth + 1);\n\n\t\trem = tree[key].svUnique;\n\t\tif (rem > 0 && tree[key].svChildren[''] === undefined) {\n\t\t\ttree[key].svChildren[''] = {\n\t\t\t    'svSynthetic': true,\n\t\t\t    'svUnique': rem,\n\t\t\t    'svTotal': rem,\n\t\t\t    'svChildren': {}\n\t\t\t};\n\t\t}\n\t}\n};\n\nFlameGraph.prototype.detailClose = function ()\n{\n\tif (this.fg_context !== null)\n\t\tthis.fg_context.detailClose();\n};\n\nFlameGraph.prototype.detailOpen = function (d)\n{\n\tif (!d.data.value.svSynthetic && this.fg_context !== null)\n\t\tthis.fg_context.detailOpen(d);\n};\n\nFlameGraph.prototype.mouseover = function (d)\n{\n\tif (d.data.value.svSynthetic || this.fg_context === null)\n\t\treturn;\n\n\tvar nsamples, nunique;\n\tvar pctSamples, pctUnique;\n\tvar detail;\n\tvar fg = this;\n\n\tnsamples = d.data.value.svTotal;\n\tpctSamples = (100 * nsamples / this.fg_depthsamples[0]).toFixed(1);\n\n\tnunique = d.data.value.svUnique;\n\tpctUnique = (100 * nunique / this.fg_depthsamples[0]).toFixed(1);\n\n\tdetail = {\n\t    'label': d.data.key,\n\t    'nsamples': d.data.value.svTotal,\n\t    'nunique': d.data.value.svUnique,\n\t    'nallsamples': this.fg_depthsamples[0],\n\t    'pctSamples': pctSamples,\n\t    'pctUnique': pctUnique,\n\t    'x': d3.event.pageX,\n\t    'y': d3.event.pageY\n\t};\n\n\tthis.fg_hoverto = setTimeout(function () {\n\t\tfg.fg_hoverto = null;\n\t\tfg.fg_context.mouseover(d, detail);\n\t}, 500);\n};\n\nFlameGraph.prototype.mouseout = function (d)\n{\n\tif (this.fg_hoverto)\n\t\tclearTimeout(this.fg_hoverto);\n\tif (this.fg_context !== null)\n\t\tthis.fg_context.mouseout(d);\n};\n\nFlameGraph.prototype.zoomSet = function (cd)\n{\n\tvar fg = this;\n\n\tthis.fg_xscale.domain([cd.x, cd.x + cd.dx]);\n\tthis.fg_rectwidth = function (d) {\n\t\treturn (fg.fg_xscale(d.x + d.dx) - fg.fg_xscale(d.x));\n\t};\n\tthis.fg_textwidth = function (d) {\n\t\treturn (Math.max(0,\n\t\t    fg.fg_xscale(d.x + d.dx) -\n\t\t    fg.fg_xscale(d.x) - svTextPaddingRight));\n\t};\n\tthis.fg_rects.transition().duration(svTransitionTime).\n\t    attr('x', this.fg_x).\n\t    attr('width', this.fg_rectwidth);\n\tthis.fg_clips.transition().duration(svTransitionTime).\n\t    attr('x', this.fg_x).\n\t    attr('width', this.fg_textwidth);\n\tthis.fg_text.transition().duration(svTransitionTime).\n\t    attr('x', this.fg_x);\n};\n\n\n/*\n * This function is copied directly from lib/color.js.  It would be better if we\n * could share code between Node.js and web JS.\n */\nfunction convertHsvToRgb(h, s, v)\n{\n\tvar r, g, b;\n\tvar i;\n\tvar f, p, q, t;\n\n\tif (s === 0) {\n\t\t/*\n\t\t * A saturation of 0.0 is achromatic (grey).\n\t\t */\n\t\tr = g = b = v;\n\n\t\treturn ([ Math.round(r * 255), Math.round(g * 255),\n\t\t    Math.round(b * 255) ]);\n\t}\n\n\th /= 60; // sector 0 to 5\n\n\ti = Math.floor(h);\n\tf = h - i; // fractional part of h\n\tp = v * (1 - s);\n\tq = v * (1 - s * f);\n\tt = v * (1 - s * (1 - f));\n\n\tswitch (i) {\n\t\tcase 0:\n\t\t\tr = v;\n\t\t\tg = t;\n\t\t\tb = p;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tr = q;\n\t\t\tg = v;\n\t\t\tb = p;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tr = p;\n\t\t\tg = v;\n\t\t\tb = t;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tr = p;\n\t\t\tg = q;\n\t\t\tb = v;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tr = t;\n\t\t\tg = p;\n\t\t\tb = v;\n\t\t\tbreak;\n\n\t\tdefault: // case 5:\n\t\t\tr = v;\n\t\t\tg = p;\n\t\t\tb = q;\n\t\t\tbreak;\n\t}\n\n\treturn ([ Math.round(r * 255),\n\t    Math.round(g * 255), Math.round(b * 255) ]);\n}\n"}